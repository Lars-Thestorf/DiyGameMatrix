
VirtualSerial.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000134e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00802000  0000134e  000013e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000580  00802008  00802008  000013ea  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  000013ea  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000013fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002c8  00000000  00000000  0000143c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a297  00000000  00000000  00001704  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c0d  00000000  00000000  0000b99b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002d86  00000000  00000000  0000f5a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000940  00000000  00000000  00012330  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000577b  00000000  00000000  00012c70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000033c8  00000000  00000000  000183eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003c8  00000000  00000000  0001b7b3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c1       	rjmp	.+648    	; 0x28a <__ctors_end>
       2:	00 00       	nop
       4:	67 c1       	rjmp	.+718    	; 0x2d4 <__bad_interrupt>
       6:	00 00       	nop
       8:	65 c1       	rjmp	.+714    	; 0x2d4 <__bad_interrupt>
       a:	00 00       	nop
       c:	63 c1       	rjmp	.+710    	; 0x2d4 <__bad_interrupt>
       e:	00 00       	nop
      10:	61 c1       	rjmp	.+706    	; 0x2d4 <__bad_interrupt>
      12:	00 00       	nop
      14:	5f c1       	rjmp	.+702    	; 0x2d4 <__bad_interrupt>
      16:	00 00       	nop
      18:	5d c1       	rjmp	.+698    	; 0x2d4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	52 c3       	rjmp	.+1700   	; 0x6c2 <__vector_7>
      1e:	00 00       	nop
      20:	31 c3       	rjmp	.+1634   	; 0x684 <__vector_8>
      22:	00 00       	nop
      24:	57 c1       	rjmp	.+686    	; 0x2d4 <__bad_interrupt>
      26:	00 00       	nop
      28:	55 c1       	rjmp	.+682    	; 0x2d4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	53 c1       	rjmp	.+678    	; 0x2d4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	51 c1       	rjmp	.+674    	; 0x2d4 <__bad_interrupt>
      32:	00 00       	nop
      34:	4f c1       	rjmp	.+670    	; 0x2d4 <__bad_interrupt>
      36:	00 00       	nop
      38:	4d c1       	rjmp	.+666    	; 0x2d4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4b c1       	rjmp	.+662    	; 0x2d4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	49 c1       	rjmp	.+658    	; 0x2d4 <__bad_interrupt>
      42:	00 00       	nop
      44:	47 c1       	rjmp	.+654    	; 0x2d4 <__bad_interrupt>
      46:	00 00       	nop
      48:	45 c1       	rjmp	.+650    	; 0x2d4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	43 c1       	rjmp	.+646    	; 0x2d4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	41 c1       	rjmp	.+642    	; 0x2d4 <__bad_interrupt>
      52:	00 00       	nop
      54:	3f c1       	rjmp	.+638    	; 0x2d4 <__bad_interrupt>
      56:	00 00       	nop
      58:	3d c1       	rjmp	.+634    	; 0x2d4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3b c1       	rjmp	.+630    	; 0x2d4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	39 c1       	rjmp	.+626    	; 0x2d4 <__bad_interrupt>
      62:	00 00       	nop
      64:	37 c1       	rjmp	.+622    	; 0x2d4 <__bad_interrupt>
      66:	00 00       	nop
      68:	35 c1       	rjmp	.+618    	; 0x2d4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	33 c1       	rjmp	.+614    	; 0x2d4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	31 c1       	rjmp	.+610    	; 0x2d4 <__bad_interrupt>
      72:	00 00       	nop
      74:	2f c1       	rjmp	.+606    	; 0x2d4 <__bad_interrupt>
      76:	00 00       	nop
      78:	2d c1       	rjmp	.+602    	; 0x2d4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2b c1       	rjmp	.+598    	; 0x2d4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	29 c1       	rjmp	.+594    	; 0x2d4 <__bad_interrupt>
      82:	00 00       	nop
      84:	27 c1       	rjmp	.+590    	; 0x2d4 <__bad_interrupt>
      86:	00 00       	nop
      88:	25 c1       	rjmp	.+586    	; 0x2d4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	23 c1       	rjmp	.+582    	; 0x2d4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	21 c1       	rjmp	.+578    	; 0x2d4 <__bad_interrupt>
      92:	00 00       	nop
      94:	1f c1       	rjmp	.+574    	; 0x2d4 <__bad_interrupt>
      96:	00 00       	nop
      98:	1d c1       	rjmp	.+570    	; 0x2d4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	1b c1       	rjmp	.+566    	; 0x2d4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	19 c1       	rjmp	.+562    	; 0x2d4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	17 c1       	rjmp	.+558    	; 0x2d4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	15 c1       	rjmp	.+554    	; 0x2d4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	13 c1       	rjmp	.+550    	; 0x2d4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	11 c1       	rjmp	.+546    	; 0x2d4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0f c1       	rjmp	.+542    	; 0x2d4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0d c1       	rjmp	.+538    	; 0x2d4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0b c1       	rjmp	.+534    	; 0x2d4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	09 c1       	rjmp	.+530    	; 0x2d4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	07 c1       	rjmp	.+526    	; 0x2d4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	05 c1       	rjmp	.+522    	; 0x2d4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	03 c1       	rjmp	.+518    	; 0x2d4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	01 c1       	rjmp	.+514    	; 0x2d4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	ff c0       	rjmp	.+510    	; 0x2d4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fd c0       	rjmp	.+506    	; 0x2d4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	fb c0       	rjmp	.+502    	; 0x2d4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f9 c0       	rjmp	.+498    	; 0x2d4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f7 c0       	rjmp	.+494    	; 0x2d4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f5 c0       	rjmp	.+490    	; 0x2d4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f3 c0       	rjmp	.+486    	; 0x2d4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f1 c0       	rjmp	.+482    	; 0x2d4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ef c0       	rjmp	.+478    	; 0x2d4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	ed c0       	rjmp	.+474    	; 0x2d4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	eb c0       	rjmp	.+470    	; 0x2d4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e9 c0       	rjmp	.+466    	; 0x2d4 <__bad_interrupt>
     102:	00 00       	nop
     104:	e7 c0       	rjmp	.+462    	; 0x2d4 <__bad_interrupt>
     106:	00 00       	nop
     108:	e5 c0       	rjmp	.+458    	; 0x2d4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e3 c0       	rjmp	.+454    	; 0x2d4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e1 c0       	rjmp	.+450    	; 0x2d4 <__bad_interrupt>
     112:	00 00       	nop
     114:	df c0       	rjmp	.+446    	; 0x2d4 <__bad_interrupt>
     116:	00 00       	nop
     118:	dd c0       	rjmp	.+442    	; 0x2d4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	db c0       	rjmp	.+438    	; 0x2d4 <__bad_interrupt>
     11e:	00 00       	nop
     120:	d9 c0       	rjmp	.+434    	; 0x2d4 <__bad_interrupt>
     122:	00 00       	nop
     124:	d7 c0       	rjmp	.+430    	; 0x2d4 <__bad_interrupt>
     126:	00 00       	nop
     128:	d5 c0       	rjmp	.+426    	; 0x2d4 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	d3 c0       	rjmp	.+422    	; 0x2d4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d1 c0       	rjmp	.+418    	; 0x2d4 <__bad_interrupt>
     132:	00 00       	nop
     134:	cf c0       	rjmp	.+414    	; 0x2d4 <__bad_interrupt>
     136:	00 00       	nop
     138:	cd c0       	rjmp	.+410    	; 0x2d4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	cb c0       	rjmp	.+406    	; 0x2d4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c9 c0       	rjmp	.+402    	; 0x2d4 <__bad_interrupt>
     142:	00 00       	nop
     144:	c7 c0       	rjmp	.+398    	; 0x2d4 <__bad_interrupt>
     146:	00 00       	nop
     148:	c5 c0       	rjmp	.+394    	; 0x2d4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c3 c0       	rjmp	.+390    	; 0x2d4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c1 c0       	rjmp	.+386    	; 0x2d4 <__bad_interrupt>
     152:	00 00       	nop
     154:	bf c0       	rjmp	.+382    	; 0x2d4 <__bad_interrupt>
     156:	00 00       	nop
     158:	bd c0       	rjmp	.+378    	; 0x2d4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	bb c0       	rjmp	.+374    	; 0x2d4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b9 c0       	rjmp	.+370    	; 0x2d4 <__bad_interrupt>
     162:	00 00       	nop
     164:	b7 c0       	rjmp	.+366    	; 0x2d4 <__bad_interrupt>
     166:	00 00       	nop
     168:	b5 c0       	rjmp	.+362    	; 0x2d4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b3 c0       	rjmp	.+358    	; 0x2d4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b1 c0       	rjmp	.+354    	; 0x2d4 <__bad_interrupt>
     172:	00 00       	nop
     174:	af c0       	rjmp	.+350    	; 0x2d4 <__bad_interrupt>
     176:	00 00       	nop
     178:	ad c0       	rjmp	.+346    	; 0x2d4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	ab c0       	rjmp	.+342    	; 0x2d4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a9 c0       	rjmp	.+338    	; 0x2d4 <__bad_interrupt>
     182:	00 00       	nop
     184:	a7 c0       	rjmp	.+334    	; 0x2d4 <__bad_interrupt>
     186:	00 00       	nop
     188:	a5 c0       	rjmp	.+330    	; 0x2d4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a3 c0       	rjmp	.+326    	; 0x2d4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a1 c0       	rjmp	.+322    	; 0x2d4 <__bad_interrupt>
     192:	00 00       	nop
     194:	9f c0       	rjmp	.+318    	; 0x2d4 <__bad_interrupt>
     196:	00 00       	nop
     198:	9d c0       	rjmp	.+314    	; 0x2d4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	9b c0       	rjmp	.+310    	; 0x2d4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	99 c0       	rjmp	.+306    	; 0x2d4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	97 c0       	rjmp	.+302    	; 0x2d4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	95 c0       	rjmp	.+298    	; 0x2d4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	93 c0       	rjmp	.+294    	; 0x2d4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	91 c0       	rjmp	.+290    	; 0x2d4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8f c0       	rjmp	.+286    	; 0x2d4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8d c0       	rjmp	.+282    	; 0x2d4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	8b c0       	rjmp	.+278    	; 0x2d4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	89 c0       	rjmp	.+274    	; 0x2d4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	87 c0       	rjmp	.+270    	; 0x2d4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	85 c0       	rjmp	.+266    	; 0x2d4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	83 c0       	rjmp	.+262    	; 0x2d4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	81 c0       	rjmp	.+258    	; 0x2d4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7f c0       	rjmp	.+254    	; 0x2d4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7d c0       	rjmp	.+250    	; 0x2d4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	7b c0       	rjmp	.+246    	; 0x2d4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	79 c0       	rjmp	.+242    	; 0x2d4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	77 c0       	rjmp	.+238    	; 0x2d4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	75 c0       	rjmp	.+234    	; 0x2d4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	73 c0       	rjmp	.+230    	; 0x2d4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	71 c0       	rjmp	.+226    	; 0x2d4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	0c 94 0d 09 	jmp	0x121a	; 0x121a <__vector_125>
     1f8:	6d c0       	rjmp	.+218    	; 0x2d4 <__bad_interrupt>
     1fa:	00 00       	nop

000001fc <ProductString>:
     1fc:	1c 03 4c 00 55 00 46 00 41 00 20 00 43 00 44 00     ..L.U.F.A. .C.D.
     20c:	43 00 20 00 44 00 65 00 6d 00 6f 00 00 00           C. .D.e.m.o...

0000021a <ManufacturerString>:
     21a:	1a 03 4c 00 55 00 46 00 41 00 20 00 4c 00 69 00     ..L.U.F.A. .L.i.
     22a:	62 00 72 00 61 00 72 00 79 00 00 00                 b.r.a.r.y...

00000236 <LanguageString>:
     236:	04 03 09 04                                         ....

0000023a <ConfigurationDescriptor>:
     23a:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     24a:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     25a:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     26a:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

00000278 <DeviceDescriptor>:
     278:	12 01 10 01 02 00 00 08 eb 03 44 20 01 00 01 02     ..........D ....
     288:	dc 01                                               ..

0000028a <__ctors_end>:
     28a:	11 24       	eor	r1, r1
     28c:	1f be       	out	0x3f, r1	; 63
     28e:	cf ef       	ldi	r28, 0xFF	; 255
     290:	cd bf       	out	0x3d, r28	; 61
     292:	df e3       	ldi	r29, 0x3F	; 63
     294:	de bf       	out	0x3e, r29	; 62
     296:	00 e0       	ldi	r16, 0x00	; 0
     298:	0c bf       	out	0x3c, r16	; 60
     29a:	18 be       	out	0x38, r1	; 56
     29c:	19 be       	out	0x39, r1	; 57
     29e:	1a be       	out	0x3a, r1	; 58
     2a0:	1b be       	out	0x3b, r1	; 59

000002a2 <__do_copy_data>:
     2a2:	10 e2       	ldi	r17, 0x20	; 32
     2a4:	a0 e0       	ldi	r26, 0x00	; 0
     2a6:	b0 e2       	ldi	r27, 0x20	; 32
     2a8:	ee e4       	ldi	r30, 0x4E	; 78
     2aa:	f3 e1       	ldi	r31, 0x13	; 19
     2ac:	00 e0       	ldi	r16, 0x00	; 0
     2ae:	0b bf       	out	0x3b, r16	; 59
     2b0:	02 c0       	rjmp	.+4      	; 0x2b6 <__do_copy_data+0x14>
     2b2:	07 90       	elpm	r0, Z+
     2b4:	0d 92       	st	X+, r0
     2b6:	a8 30       	cpi	r26, 0x08	; 8
     2b8:	b1 07       	cpc	r27, r17
     2ba:	d9 f7       	brne	.-10     	; 0x2b2 <__do_copy_data+0x10>
     2bc:	1b be       	out	0x3b, r1	; 59

000002be <__do_clear_bss>:
     2be:	25 e2       	ldi	r18, 0x25	; 37
     2c0:	a8 e0       	ldi	r26, 0x08	; 8
     2c2:	b0 e2       	ldi	r27, 0x20	; 32
     2c4:	01 c0       	rjmp	.+2      	; 0x2c8 <.do_clear_bss_start>

000002c6 <.do_clear_bss_loop>:
     2c6:	1d 92       	st	X+, r1

000002c8 <.do_clear_bss_start>:
     2c8:	a8 38       	cpi	r26, 0x88	; 136
     2ca:	b2 07       	cpc	r27, r18
     2cc:	e1 f7       	brne	.-8      	; 0x2c6 <.do_clear_bss_loop>
     2ce:	d1 d1       	rcall	.+930    	; 0x672 <main>
     2d0:	0c 94 a5 09 	jmp	0x134a	; 0x134a <_exit>

000002d4 <__bad_interrupt>:
     2d4:	95 ce       	rjmp	.-726    	; 0x0 <__vectors>

000002d6 <SetupHardware>:
				  return false;

				switch (Source)
				{
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.PLLCTRL = (OSC_PLLSRC_RC2M_gc  | MulFactor);
     2d6:	88 e1       	ldi	r24, 0x18	; 24
     2d8:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x7de055>
						break;
					default:
						return false;
				}

				OSC.CTRL |= OSC_PLLEN_bm;
     2dc:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
     2e0:	80 61       	ori	r24, 0x10	; 16
     2e2:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>

				while (!(OSC.STATUS & OSC_PLLRDY_bm));
     2e6:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7de051>
     2ea:	84 ff       	sbrs	r24, 4
     2ec:	fc cf       	rjmp	.-8      	; 0x2e6 <SetupHardware+0x10>
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
     2ee:	8f b7       	in	r24, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
     2f0:	f8 94       	cli
			 *  \param[in] Value    Value to write to the protected location
			 */
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value) ATTR_NON_NULL_PTR_ARG(1) ATTR_ALWAYS_INLINE;
			static inline void XMEGACLK_CCP_Write(volatile void* Address, const uint8_t Value)
			{
				__asm__ __volatile__ (
     2f2:	94 e0       	ldi	r25, 0x04	; 4
     2f4:	28 ed       	ldi	r18, 0xD8	; 216
     2f6:	30 e0       	ldi	r19, 0x00	; 0
     2f8:	a0 e4       	ldi	r26, 0x40	; 64
     2fa:	b0 e0       	ldi	r27, 0x00	; 0
     2fc:	1b be       	out	0x3b, r1	; 59
     2fe:	fd 01       	movw	r30, r26
     300:	24 bf       	out	0x34, r18	; 52
     302:	90 83       	st	Z, r25
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
     304:	8f bf       	out	0x3f, r24	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     306:	8f ed       	ldi	r24, 0xDF	; 223
     308:	9e e2       	ldi	r25, 0x2E	; 46
     30a:	01 97       	sbiw	r24, 0x01	; 1
     30c:	f1 f7       	brne	.-4      	; 0x30a <SetupHardware+0x34>
     30e:	00 c0       	rjmp	.+0      	; 0x310 <SetupHardware+0x3a>
     310:	00 00       	nop
				XMEGACLK_CCP_Write(&CLK.CTRL, ClockSourceMask);

				SetGlobalInterruptMask(CurrentGlobalInt);

				Delay_MS(1);
				return (CLK.CTRL == ClockSourceMask);
     312:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7de040>
					case CLOCK_SRC_INT_RC2MHZ:
						OSC.CTRL |= OSC_RC2MEN_bm;
						while (!(OSC.STATUS & OSC_RC2MRDY_bm));
						return true;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.CTRL |= OSC_RC32MEN_bm;
     316:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
     31a:	82 60       	ori	r24, 0x02	; 2
     31c:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
						while (!(OSC.STATUS & OSC_RC32MRDY_bm));
     320:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7de051>
     324:	81 ff       	sbrs	r24, 1
     326:	fc cf       	rjmp	.-8      	; 0x320 <SetupHardware+0x4a>
						DFLLRC2M.COMP1  = (DFLLCompare & 0xFF);
						DFLLRC2M.COMP2  = (DFLLCompare >> 8);
						DFLLRC2M.CTRL   = DFLL_ENABLE_bm;
						break;
					case CLOCK_SRC_INT_RC32MHZ:
						OSC.DFLLCTRL   |= (Reference << OSC_RC32MCREF_gp);
     328:	80 91 56 00 	lds	r24, 0x0056	; 0x800056 <__TEXT_REGION_LENGTH__+0x7de056>
     32c:	84 60       	ori	r24, 0x04	; 4
     32e:	80 93 56 00 	sts	0x0056, r24	; 0x800056 <__TEXT_REGION_LENGTH__+0x7de056>
						DFLLRC32M.COMP1 = (DFLLCompare & 0xFF);
     332:	8b e1       	ldi	r24, 0x1B	; 27
     334:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <__TEXT_REGION_LENGTH__+0x7de065>
						DFLLRC32M.COMP2 = (DFLLCompare >> 8);
     338:	87 eb       	ldi	r24, 0xB7	; 183
     33a:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__TEXT_REGION_LENGTH__+0x7de066>

						if (Reference == DFLL_REF_INT_USBSOF)
						{
							NVM.CMD        = NVM_CMD_READ_CALIB_ROW_gc;
     33e:	82 e0       	ldi	r24, 0x02	; 2
     340:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7de1ca>
							DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
     344:	ed e1       	ldi	r30, 0x1D	; 29
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	e4 91       	lpm	r30, Z
     34a:	e0 93 62 00 	sts	0x0062, r30	; 0x800062 <__TEXT_REGION_LENGTH__+0x7de062>
							DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
     34e:	ec e1       	ldi	r30, 0x1C	; 28
     350:	f0 e0       	ldi	r31, 0x00	; 0
     352:	e4 91       	lpm	r30, Z
     354:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <__TEXT_REGION_LENGTH__+0x7de063>
							NVM.CMD        = 0;
     358:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7de1ca>
						}

						DFLLRC32M.CTRL  = DFLL_ENABLE_bm;
     35c:	81 e0       	ldi	r24, 0x01	; 1
     35e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7de060>

	/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
     362:	87 e0       	ldi	r24, 0x07	; 7
     364:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7de0a2>
#endif

	/* Hardware Initialization */
	USB_Init();
     368:	21 c7       	rjmp	.+3650   	; 0x11ac <USB_Init>

0000036a <uart_rx_ring_buffer_init>:
}
void uart_rx_ring_buffer_init(void)
{
     36a:	cf 93       	push	r28
     36c:	df 93       	push	r29
     36e:	00 d0       	rcall	.+0      	; 0x370 <uart_rx_ring_buffer_init+0x6>
     370:	cd b7       	in	r28, 0x3d	; 61
     372:	de b7       	in	r29, 0x3e	; 62
	DMA.CH2.CTRLA                         = DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm;
     374:	e0 e0       	ldi	r30, 0x00	; 0
     376:	f1 e0       	ldi	r31, 0x01	; 1
     378:	84 e2       	ldi	r24, 0x24	; 36
     37a:	80 ab       	std	Z+48, r24	; 0x30
	DMA.CH2.CTRLB                         = DMA_CH_TRNINTLVL_OFF_gc | DMA_CH_TRNIF_bm;
     37c:	80 e1       	ldi	r24, 0x10	; 16
     37e:	81 ab       	std	Z+49, r24	; 0x31

	__int24 dst = (__int24)(int16_t)uart_rx_ring_buffer;
     380:	8f e0       	ldi	r24, 0x0F	; 15
     382:	92 e2       	ldi	r25, 0x22	; 34
     384:	9c 01       	movw	r18, r24
     386:	99 0f       	add	r25, r25
     388:	44 0b       	sbc	r20, r20
     38a:	29 83       	std	Y+1, r18	; 0x01
     38c:	3a 83       	std	Y+2, r19	; 0x02
     38e:	4b 83       	std	Y+3, r20	; 0x03
	__int24 src = (__int24)(int16_t)&USARTC1.DATA;

	DMA.CH2.REPCNT                        = 0;
     390:	16 aa       	std	Z+54, r1	; 0x36
	DMA.CH2.TRFCNT                        = (uint16_t) 128;
     392:	20 e8       	ldi	r18, 0x80	; 128
     394:	30 e0       	ldi	r19, 0x00	; 0
     396:	24 ab       	std	Z+52, r18	; 0x34
     398:	35 ab       	std	Z+53, r19	; 0x35
	DMA.CH2.ADDRCTRL                      = DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTDIR_INC_gc | DMA_CH_DESTRELOAD_TRANSACTION_gc;
     39a:	9d ec       	ldi	r25, 0xCD	; 205
     39c:	92 ab       	std	Z+50, r25	; 0x32
	DMA.CH2.TRIGSRC                       = DMA_CH_TRIGSRC_USARTC1_RXC_gc;
     39e:	9e e4       	ldi	r25, 0x4E	; 78
     3a0:	93 ab       	std	Z+51, r25	; 0x33

	DMA.CH2.DESTADDR0                     = (uint8_t) (uint16_t) dst;
     3a2:	84 af       	std	Z+60, r24	; 0x3c
	DMA.CH2.DESTADDR1                     = (uint8_t)  *(((uint8_t *)&(dst)) + 1);
     3a4:	8a 81       	ldd	r24, Y+2	; 0x02
     3a6:	85 af       	std	Z+61, r24	; 0x3d
	DMA.CH2.DESTADDR2                     = (uint8_t)  *(((uint8_t *)&(dst)) + 2);
     3a8:	8b 81       	ldd	r24, Y+3	; 0x03
     3aa:	86 af       	std	Z+62, r24	; 0x3e

	DMA.CH2.SRCADDR0                      = (uint8_t) (uint16_t) src;
     3ac:	80 eb       	ldi	r24, 0xB0	; 176
     3ae:	80 af       	std	Z+56, r24	; 0x38
	DMA.CH2.SRCADDR1                      = (uint8_t)  *(((uint8_t *)&(src)) + 1);
     3b0:	88 e0       	ldi	r24, 0x08	; 8
     3b2:	81 af       	std	Z+57, r24	; 0x39
	DMA.CH2.SRCADDR2                      = (uint8_t)  *(((uint8_t *)&(src)) + 2); 
     3b4:	12 ae       	std	Z+58, r1	; 0x3a

	DMA.CH2.CTRLA                        |= DMA_CH_ENABLE_bm;
     3b6:	80 a9       	ldd	r24, Z+48	; 0x30
     3b8:	80 68       	ori	r24, 0x80	; 128
     3ba:	80 ab       	std	Z+48, r24	; 0x30
}
     3bc:	23 96       	adiw	r28, 0x03	; 3
     3be:	cd bf       	out	0x3d, r28	; 61
     3c0:	de bf       	out	0x3e, r29	; 62
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <uart_tx_buffer_init>:

void uart_tx_buffer_init(void)
{
	DMA.CTRL = DMA_PRIMODE_CH0123_gc | DMA_ENABLE_bm;
     3c8:	e0 e0       	ldi	r30, 0x00	; 0
     3ca:	f1 e0       	ldi	r31, 0x01	; 1
     3cc:	83 e8       	ldi	r24, 0x83	; 131
     3ce:	80 83       	st	Z, r24

	DMA.CH1.CTRLA                         = DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm;
     3d0:	84 e0       	ldi	r24, 0x04	; 4
     3d2:	80 a3       	std	Z+32, r24	; 0x20
	DMA.CH1.CTRLB                         = DMA_CH_TRNINTLVL_MED_gc | DMA_CH_TRNIF_bm;
     3d4:	82 e1       	ldi	r24, 0x12	; 18
     3d6:	81 a3       	std	Z+33, r24	; 0x21

	__int24 dst = (__int24)(int16_t)&USARTC1.DATA;

	DMA.CH1.REPCNT                        = 1;
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	86 a3       	std	Z+38, r24	; 0x26

	DMA.CH1.ADDRCTRL                      = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc;
     3dc:	80 e1       	ldi	r24, 0x10	; 16
     3de:	82 a3       	std	Z+34, r24	; 0x22
	DMA.CH1.TRIGSRC                       = DMA_CH_TRIGSRC_USARTC1_DRE_gc;
     3e0:	8f e4       	ldi	r24, 0x4F	; 79
     3e2:	83 a3       	std	Z+35, r24	; 0x23

	DMA.CH1.DESTADDR0                     = (uint8_t) (uint16_t) dst;
     3e4:	80 eb       	ldi	r24, 0xB0	; 176
     3e6:	84 a7       	std	Z+44, r24	; 0x2c
	DMA.CH1.DESTADDR1                     = (uint8_t)  *(((uint8_t *)&(dst)) + 1);
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	85 a7       	std	Z+45, r24	; 0x2d
	DMA.CH1.DESTADDR2                     = (uint8_t)  *(((uint8_t *)&(dst)) + 2);
     3ec:	16 a6       	std	Z+46, r1	; 0x2e
     3ee:	08 95       	ret

000003f0 <uart_tx_dma_transfer_init>:
}

void uart_tx_dma_transfer_init(void)
{
     3f0:	cf 93       	push	r28
     3f2:	df 93       	push	r29
     3f4:	00 d0       	rcall	.+0      	; 0x3f6 <uart_tx_dma_transfer_init+0x6>
     3f6:	cd b7       	in	r28, 0x3d	; 61
     3f8:	de b7       	in	r29, 0x3e	; 62
	__int24 src = (__int24)(uint16_t)&uart_tx_buffer[uart_tx_buffer_dma_pos][0];
     3fa:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     3fe:	20 e8       	ldi	r18, 0x80	; 128
     400:	82 9f       	mul	r24, r18
     402:	c0 01       	movw	r24, r0
     404:	11 24       	eor	r1, r1
     406:	85 5f       	subi	r24, 0xF5	; 245
     408:	9f 4d       	sbci	r25, 0xDF	; 223
     40a:	9c 01       	movw	r18, r24
     40c:	40 e0       	ldi	r20, 0x00	; 0
     40e:	29 83       	std	Y+1, r18	; 0x01
     410:	3a 83       	std	Y+2, r19	; 0x02
     412:	4b 83       	std	Y+3, r20	; 0x03
	dma_ready = false;
     414:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <__DATA_REGION_ORIGIN__>
	DMA.CH1.TRFCNT                        = uart_tx_buffer_trfcnt[uart_tx_buffer_dma_pos];
     418:	e0 91 09 20 	lds	r30, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     41c:	f0 e0       	ldi	r31, 0x00	; 0
     41e:	e5 5f       	subi	r30, 0xF5	; 245
     420:	fd 4d       	sbci	r31, 0xDD	; 221
     422:	20 81       	ld	r18, Z
     424:	30 e0       	ldi	r19, 0x00	; 0
     426:	e0 e0       	ldi	r30, 0x00	; 0
     428:	f1 e0       	ldi	r31, 0x01	; 1
     42a:	24 a3       	std	Z+36, r18	; 0x24
     42c:	35 a3       	std	Z+37, r19	; 0x25

	DMA.CH1.SRCADDR0                      = (uint8_t) (uint16_t) src;
     42e:	80 a7       	std	Z+40, r24	; 0x28
	DMA.CH1.SRCADDR1                      = (uint8_t)  *(((uint8_t *)&(src)) + 1);
     430:	8a 81       	ldd	r24, Y+2	; 0x02
     432:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2                      = (uint8_t)  *(((uint8_t *)&(src)) + 2); 
     434:	8b 81       	ldd	r24, Y+3	; 0x03
     436:	82 a7       	std	Z+42, r24	; 0x2a
	DMA.CH1.CTRLA                        |= DMA_CH_ENABLE_bm;
     438:	80 a1       	ldd	r24, Z+32	; 0x20
     43a:	80 68       	ori	r24, 0x80	; 128
     43c:	80 a3       	std	Z+32, r24	; 0x20
}
     43e:	23 96       	adiw	r28, 0x03	; 3
     440:	cd bf       	out	0x3d, r28	; 61
     442:	de bf       	out	0x3e, r29	; 62
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	08 95       	ret

0000044a <SetupUart>:

void SetupUart(){
	PORTC.DIRCLR = PIN6_bm;    // pin PC2 (RXC1) as input
     44a:	e0 e4       	ldi	r30, 0x40	; 64
     44c:	f6 e0       	ldi	r31, 0x06	; 6
     44e:	80 e4       	ldi	r24, 0x40	; 64
     450:	82 83       	std	Z+2, r24	; 0x02
	PORTC.DIRSET = PIN7_bm;    // pin PC3 (TXC1) as output
     452:	80 e8       	ldi	r24, 0x80	; 128
     454:	81 83       	std	Z+1, r24	; 0x01
	USARTC1.CTRLC = USART_CHSIZE_8BIT_gc | USART_PMODE_DISABLED_gc;   // 8N1
     456:	e0 eb       	ldi	r30, 0xB0	; 176
     458:	f8 e0       	ldi	r31, 0x08	; 8
     45a:	83 e0       	ldi	r24, 0x03	; 3
     45c:	85 83       	std	Z+5, r24	; 0x05

	uint32_t baud = 115200;
	uint16_t val = (((uint32_t)F_CPU * 2) + baud*8)/(baud*16) - 1;
	USARTC1.BAUDCTRLA = val & 0xFF;
     45e:	83 e3       	ldi	r24, 0x33	; 51
     460:	86 83       	std	Z+6, r24	; 0x06
	USARTC1.BAUDCTRLB = val >> 8;
     462:	17 82       	std	Z+7, r1	; 0x07

	USARTC1.CTRLA = USART_RXCINTLVL_OFF_gc;
     464:	13 82       	std	Z+3, r1	; 0x03

	USARTC1.CTRLB |= USART_TXEN_bm | USART_RXEN_bm | USART_CLK2X_bm;   // enable TX+RX and Clock
     466:	84 81       	ldd	r24, Z+4	; 0x04
     468:	8c 61       	ori	r24, 0x1C	; 28
     46a:	84 83       	std	Z+4, r24	; 0x04
     46c:	08 95       	ret

0000046e <SetupAdditionalPins>:
}
void SetupAdditionalPins(){
	PIN_BOOT_reg.PASTE3(PIN, PIN_BOOT_bit, CTRL) = PORT_OPC_PULLUP_gc;
     46e:	e0 e4       	ldi	r30, 0x40	; 64
     470:	f6 e0       	ldi	r31, 0x06	; 6
     472:	88 e1       	ldi	r24, 0x18	; 24
     474:	80 8b       	std	Z+16, r24	; 0x10
	PIN_EN_reg.PASTE3(PIN, PIN_EN_bit, CTRL) = PORT_OPC_PULLUP_gc;
     476:	81 8b       	std	Z+17, r24	; 0x11
	PIN_BOOT_reg.OUTCLR = 1 << PIN_BOOT_bit;
     478:	81 e0       	ldi	r24, 0x01	; 1
     47a:	86 83       	std	Z+6, r24	; 0x06
	PIN_EN_reg.OUTCLR = 1 << PIN_EN_bit;
     47c:	82 e0       	ldi	r24, 0x02	; 2
     47e:	86 83       	std	Z+6, r24	; 0x06
     480:	08 95       	ret

00000482 <EVENT_USB_Device_Connect>:
     482:	08 95       	ret

00000484 <EVENT_USB_Device_Disconnect>:

/** Event handler for the USB_Disconnect event. This indicates that the device is no longer connected to a host via
 *  the status LEDs and stops the USB management and CDC management tasks.
 */
void EVENT_USB_Device_Disconnect(void)
{
     484:	08 95       	ret

00000486 <EVENT_USB_Device_ConfigurationChanged>:
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
     486:	40 e1       	ldi	r20, 0x10	; 16
     488:	69 e8       	ldi	r22, 0x89	; 137
     48a:	83 e8       	ldi	r24, 0x83	; 131
     48c:	b7 d5       	rcall	.+2926   	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
     48e:	40 e1       	ldi	r20, 0x10	; 16
     490:	69 e8       	ldi	r22, 0x89	; 137
     492:	84 e0       	ldi	r24, 0x04	; 4
     494:	b3 d5       	rcall	.+2918   	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
     496:	48 e0       	ldi	r20, 0x08	; 8
     498:	68 e8       	ldi	r22, 0x88	; 136
     49a:	82 e8       	ldi	r24, 0x82	; 130
     49c:	af d5       	rcall	.+2910   	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPADDR, EP_TYPE_BULK,  CDC_TXRX_EPSIZE, 1);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPADDR, EP_TYPE_INTERRUPT, CDC_NOTIFICATION_EPSIZE, 1);

	/* Reset line encoding baud rate so that the host knows to send new values */
	LineEncoding.BaudRateBPS = 0;
     49e:	10 92 01 20 	sts	0x2001, r1	; 0x802001 <LineEncoding>
     4a2:	10 92 02 20 	sts	0x2002, r1	; 0x802002 <LineEncoding+0x1>
     4a6:	10 92 03 20 	sts	0x2003, r1	; 0x802003 <LineEncoding+0x2>
     4aa:	10 92 04 20 	sts	0x2004, r1	; 0x802004 <LineEncoding+0x3>
     4ae:	08 95       	ret

000004b0 <EVENT_USB_Device_ControlRequest>:
/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
     4b0:	0f 93       	push	r16
     4b2:	1f 93       	push	r17
	/* Process CDC specific control requests */
	switch (USB_ControlRequest.bRequest)
     4b4:	80 91 95 22 	lds	r24, 0x2295	; 0x802295 <USB_ControlRequest+0x1>
     4b8:	81 32       	cpi	r24, 0x21	; 33
     4ba:	39 f0       	breq	.+14     	; 0x4ca <EVENT_USB_Device_ControlRequest+0x1a>
     4bc:	82 32       	cpi	r24, 0x22	; 34
     4be:	09 f4       	brne	.+2      	; 0x4c2 <EVENT_USB_Device_ControlRequest+0x12>
     4c0:	45 c0       	rjmp	.+138    	; 0x54c <EVENT_USB_Device_ControlRequest+0x9c>
     4c2:	80 32       	cpi	r24, 0x20	; 32
     4c4:	09 f0       	breq	.+2      	; 0x4c8 <EVENT_USB_Device_ControlRequest+0x18>
     4c6:	60 c0       	rjmp	.+192    	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
     4c8:	0e c0       	rjmp	.+28     	; 0x4e6 <EVENT_USB_Device_ControlRequest+0x36>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     4ca:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <USB_ControlRequest>
     4ce:	81 3a       	cpi	r24, 0xA1	; 161
     4d0:	09 f0       	breq	.+2      	; 0x4d4 <EVENT_USB_Device_ControlRequest+0x24>
     4d2:	5a c0       	rjmp	.+180    	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
			{
				Endpoint_ClearSETUP();
     4d4:	4c d5       	rcall	.+2712   	; 0xf6e <Endpoint_ClearSETUP>

				/* Write the line coding data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
     4d6:	67 e0       	ldi	r22, 0x07	; 7
     4d8:	70 e0       	ldi	r23, 0x00	; 0
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	90 e2       	ldi	r25, 0x20	; 32
     4de:	3b d3       	rcall	.+1654   	; 0xb56 <Endpoint_Write_Control_Stream_LE>
					PIN_BOOT_reg.DIRCLR = 1 << PIN_BOOT_bit; //Boot floating
				}
			}
			break;
	}
}
     4e0:	1f 91       	pop	r17
			{
				Endpoint_ClearSETUP();

				/* Write the line coding data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
				Endpoint_ClearOUT();
     4e2:	0f 91       	pop	r16
     4e4:	a0 c4       	rjmp	.+2368   	; 0xe26 <Endpoint_ClearOUT>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     4e6:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <USB_ControlRequest>
     4ea:	81 32       	cpi	r24, 0x21	; 33
     4ec:	09 f0       	breq	.+2      	; 0x4f0 <EVENT_USB_Device_ControlRequest+0x40>
			{
				Endpoint_ClearSETUP();
     4ee:	4c c0       	rjmp	.+152    	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
     4f0:	3e d5       	rcall	.+2684   	; 0xf6e <Endpoint_ClearSETUP>

				/* Read the line coding data in from the host into the global struct */
				Endpoint_Read_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
     4f2:	67 e0       	ldi	r22, 0x07	; 7
     4f4:	70 e0       	ldi	r23, 0x00	; 0
     4f6:	81 e0       	ldi	r24, 0x01	; 1
     4f8:	90 e2       	ldi	r25, 0x20	; 32
				Endpoint_ClearIN();
     4fa:	a9 d3       	rcall	.+1874   	; 0xc4e <Endpoint_Read_Control_Stream_LE>
     4fc:	7b d4       	rcall	.+2294   	; 0xdf4 <Endpoint_ClearIN>

				uint32_t baud = LineEncoding.BaudRateBPS;
     4fe:	00 91 01 20 	lds	r16, 0x2001	; 0x802001 <LineEncoding>
     502:	10 91 02 20 	lds	r17, 0x2002	; 0x802002 <LineEncoding+0x1>
     506:	20 91 03 20 	lds	r18, 0x2003	; 0x802003 <LineEncoding+0x2>
     50a:	30 91 04 20 	lds	r19, 0x2004	; 0x802004 <LineEncoding+0x3>
				uint16_t val = (((uint32_t)F_CPU * 2) + baud*8)/(baud*16) - 1;
     50e:	d9 01       	movw	r26, r18
     510:	c8 01       	movw	r24, r16
     512:	95 5e       	subi	r25, 0xE5	; 229
     514:	a8 44       	sbci	r26, 0x48	; 72
     516:	bf 4f       	sbci	r27, 0xFF	; 255
     518:	bc 01       	movw	r22, r24
     51a:	cd 01       	movw	r24, r26
     51c:	43 e0       	ldi	r20, 0x03	; 3
     51e:	66 0f       	add	r22, r22
     520:	77 1f       	adc	r23, r23
     522:	88 1f       	adc	r24, r24
     524:	99 1f       	adc	r25, r25
     526:	4a 95       	dec	r20
     528:	d1 f7       	brne	.-12     	; 0x51e <EVENT_USB_Device_ControlRequest+0x6e>
     52a:	a9 01       	movw	r20, r18
     52c:	98 01       	movw	r18, r16
     52e:	e4 e0       	ldi	r30, 0x04	; 4
     530:	22 0f       	add	r18, r18
     532:	33 1f       	adc	r19, r19
     534:	44 1f       	adc	r20, r20
     536:	55 1f       	adc	r21, r21
     538:	ea 95       	dec	r30
     53a:	d1 f7       	brne	.-12     	; 0x530 <EVENT_USB_Device_ControlRequest+0x80>
     53c:	e4 d6       	rcall	.+3528   	; 0x1306 <__udivmodsi4>
     53e:	21 50       	subi	r18, 0x01	; 1
     540:	31 09       	sbc	r19, r1
				USARTC1.BAUDCTRLA = val & 0xFF;
     542:	20 93 b6 08 	sts	0x08B6, r18	; 0x8008b6 <__TEXT_REGION_LENGTH__+0x7de8b6>
				USARTC1.BAUDCTRLB = val >> 8;
     546:	30 93 b7 08 	sts	0x08B7, r19	; 0x8008b7 <__TEXT_REGION_LENGTH__+0x7de8b7>
				#endif
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     54a:	1e c0       	rjmp	.+60     	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
     54c:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <USB_ControlRequest>
			{
				Endpoint_ClearSETUP();
     550:	81 32       	cpi	r24, 0x21	; 33
     552:	d1 f4       	brne	.+52     	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
				Endpoint_ClearStatusStage();
     554:	0c d5       	rcall	.+2584   	; 0xf6e <Endpoint_ClearSETUP>
     556:	a3 d5       	rcall	.+2886   	; 0x109e <Endpoint_ClearStatusStage>

				/* NOTE: Here you can read in the line state mask from the host, to get the current state of the output handshake
						lines. The mask is read in from the wValue parameter in USB_ControlRequest, and can be masked against the
						CONTROL_LINE_OUT_* masks to determine the RTS and DTR line states using the following code:
				*/
				bool DTR = (USB_ControlRequest.wValue & CDC_CONTROL_LINE_OUT_DTR) != 0;
     558:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>
     55c:	90 91 97 22 	lds	r25, 0x2297	; 0x802297 <USB_ControlRequest+0x3>
     560:	9c 01       	movw	r18, r24
     562:	21 70       	andi	r18, 0x01	; 1
     564:	33 27       	eor	r19, r19
				if (DTR==0 && RTS==1)
					DebugSendChar('2');
				if (DTR==1 && RTS==1)
					DebugSendChar('3');
#endif
				if (RTS){
     566:	81 ff       	sbrs	r24, 1
     568:	04 c0       	rjmp	.+8      	; 0x572 <EVENT_USB_Device_ControlRequest+0xc2>
					PIN_EN_reg.DIRSET = 1 << PIN_EN_bit; //Reset LOW
     56a:	82 e0       	ldi	r24, 0x02	; 2
     56c:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x7de641>
     570:	03 c0       	rjmp	.+6      	; 0x578 <EVENT_USB_Device_ControlRequest+0xc8>
				} else {
					PIN_EN_reg.DIRCLR = 1 << PIN_EN_bit; //Reset floating
     572:	82 e0       	ldi	r24, 0x02	; 2
     574:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x7de642>
				}
				if (DTR){
					PIN_BOOT_reg.DIRSET = 1 << PIN_BOOT_bit; //Boot LOW
     578:	81 e0       	ldi	r24, 0x01	; 1
				if (RTS){
					PIN_EN_reg.DIRSET = 1 << PIN_EN_bit; //Reset LOW
				} else {
					PIN_EN_reg.DIRCLR = 1 << PIN_EN_bit; //Reset floating
				}
				if (DTR){
     57a:	23 2b       	or	r18, r19
     57c:	19 f0       	breq	.+6      	; 0x584 <EVENT_USB_Device_ControlRequest+0xd4>
					PIN_BOOT_reg.DIRSET = 1 << PIN_BOOT_bit; //Boot LOW
     57e:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x7de641>
     582:	02 c0       	rjmp	.+4      	; 0x588 <EVENT_USB_Device_ControlRequest+0xd8>
				} else {
					PIN_BOOT_reg.DIRCLR = 1 << PIN_BOOT_bit; //Boot floating
     584:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x7de642>
				}
			}
			break;
	}
}
     588:	1f 91       	pop	r17
     58a:	0f 91       	pop	r16
     58c:	08 95       	ret

0000058e <CDC_Task>:

/** Function to manage CDC data transmission and reception to and from the host. */
void CDC_Task(void)
{
     58e:	cf 93       	push	r28
     590:	df 93       	push	r29
	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     592:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     596:	84 30       	cpi	r24, 0x04	; 4
     598:	09 f0       	breq	.+2      	; 0x59c <CDC_Task+0xe>
     59a:	68 c0       	rjmp	.+208    	; 0x66c <CDC_Task+0xde>
	  return;

	/* If we have a free buffer receive data from endpoint */
	uint8_t next_tx_buffer_usb_pos = ((uart_tx_buffer_usb_pos + 1) & 0b11);
     59c:	c0 91 08 20 	lds	r28, 0x2008	; 0x802008 <__data_end>
     5a0:	cf 5f       	subi	r28, 0xFF	; 255
     5a2:	c3 70       	andi	r28, 0x03	; 3
	if(next_tx_buffer_usb_pos != uart_tx_buffer_dma_pos) //If the next buffer still in work we should not use it for new data.
     5a4:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     5a8:	c8 17       	cp	r28, r24
     5aa:	91 f1       	breq	.+100    	; 0x610 <CDC_Task+0x82>
	{
		Endpoint_SelectEndpoint(CDC_RX_EPADDR);
     5ac:	84 e0       	ldi	r24, 0x04	; 4
     5ae:	6a d4       	rcall	.+2260   	; 0xe84 <Endpoint_SelectEndpoint>

		/* Check to see if any data has been received */
		if (Endpoint_IsOUTReceived())
     5b0:	aa d4       	rcall	.+2388   	; 0xf06 <Endpoint_IsOUTReceived>
     5b2:	88 23       	and	r24, r24
     5b4:	69 f1       	breq	.+90     	; 0x610 <CDC_Task+0x82>
     5b6:	20 91 a0 22 	lds	r18, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
     5ba:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     5be:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     5c2:	fc 01       	movw	r30, r24
				  return USB_Endpoint_SelectedFIFO->Position;
     5c4:	27 ff       	sbrs	r18, 7
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
     5c6:	04 c0       	rjmp	.+8      	; 0x5d0 <CDC_Task+0x42>
     5c8:	ef 5b       	subi	r30, 0xBF	; 191
				  return USB_Endpoint_SelectedFIFO->Position;
     5ca:	ff 4f       	sbci	r31, 0xFF	; 255
     5cc:	60 81       	ld	r22, Z
     5ce:	08 c0       	rjmp	.+16     	; 0x5e0 <CDC_Task+0x52>
     5d0:	e0 5c       	subi	r30, 0xC0	; 192
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
     5d2:	ff 4f       	sbci	r31, 0xFF	; 255
     5d4:	60 81       	ld	r22, Z
     5d6:	31 96       	adiw	r30, 0x01	; 1
     5d8:	80 81       	ld	r24, Z
     5da:	70 e0       	ldi	r23, 0x00	; 0
     5dc:	68 1b       	sub	r22, r24
     5de:	71 09       	sbc	r23, r1
     5e0:	61 38       	cpi	r22, 0x81	; 129
     5e2:	08 f0       	brcs	.+2      	; 0x5e6 <CDC_Task+0x58>
     5e4:	60 e8       	ldi	r22, 0x80	; 128
     5e6:	e0 91 08 20 	lds	r30, 0x2008	; 0x802008 <__data_end>

            //Avoid to get more bytes then buffer size.
			if(datalen > ENDPOINT_RX_UART_TX_BYTES)
				datalen = ENDPOINT_RX_UART_TX_BYTES;

            uart_tx_buffer_trfcnt[uart_tx_buffer_usb_pos] = datalen;
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	e5 5f       	subi	r30, 0xF5	; 245
     5ee:	fd 4d       	sbci	r31, 0xDD	; 221
     5f0:	60 83       	st	Z, r22
     5f2:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <__data_end>

			/* Read in the incoming packet into the buffer */
			Endpoint_Read_Stream_LE(&uart_tx_buffer[uart_tx_buffer_usb_pos][0], datalen, NULL);
     5f6:	70 e0       	ldi	r23, 0x00	; 0
     5f8:	20 e8       	ldi	r18, 0x80	; 128
     5fa:	82 9f       	mul	r24, r18
     5fc:	c0 01       	movw	r24, r0
     5fe:	11 24       	eor	r1, r1
     600:	40 e0       	ldi	r20, 0x00	; 0
     602:	50 e0       	ldi	r21, 0x00	; 0
     604:	85 5f       	subi	r24, 0xF5	; 245
     606:	9f 4d       	sbci	r25, 0xDF	; 223
     608:	59 d2       	rcall	.+1202   	; 0xabc <Endpoint_Read_Stream_LE>
     60a:	c0 93 08 20 	sts	0x2008, r28	; 0x802008 <__data_end>

			uart_tx_buffer_usb_pos = next_tx_buffer_usb_pos;
     60e:	0b d4       	rcall	.+2070   	; 0xe26 <Endpoint_ClearOUT>
			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();
     610:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
		}
	}
	if(dma_ready && uart_tx_buffer_dma_pos != uart_tx_buffer_usb_pos) //Ready will be false after the call...
     614:	88 23       	and	r24, r24
     616:	31 f0       	breq	.+12     	; 0x624 <CDC_Task+0x96>
     618:	90 91 09 20 	lds	r25, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     61c:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <__data_end>
     620:	98 13       	cpse	r25, r24
     622:	e6 de       	rcall	.-564    	; 0x3f0 <uart_tx_dma_transfer_init>
	{
		uart_tx_dma_transfer_init();
     624:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <__TEXT_REGION_LENGTH__+0x7de134>
	}

	uint8_t dma_pos = 128 - DMA.CH2.TRFCNTL;
     628:	c0 e8       	ldi	r28, 0x80	; 128
     62a:	dc 2f       	mov	r29, r28
     62c:	d8 1b       	sub	r29, r24
     62e:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uart_rx_ring_read_pos>
	if(dma_pos != uart_rx_ring_read_pos)
     632:	d8 17       	cp	r29, r24
     634:	d9 f0       	breq	.+54     	; 0x66c <CDC_Task+0xde>
     636:	83 e8       	ldi	r24, 0x83	; 131
	{
		/* Select the Serial Tx Endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPADDR);
     638:	25 d4       	rcall	.+2122   	; 0xe84 <Endpoint_SelectEndpoint>
     63a:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uart_rx_ring_read_pos>

		uint8_t bytes_to_transfer;
		if(uart_rx_ring_read_pos < dma_pos)
     63e:	8d 17       	cp	r24, r29
     640:	08 f4       	brcc	.+2      	; 0x644 <CDC_Task+0xb6>
     642:	cd 2f       	mov	r28, r29
     644:	c8 1b       	sub	r28, r24
		{
			bytes_to_transfer = dma_pos - uart_rx_ring_read_pos;
     646:	6c 2f       	mov	r22, r28
		}
		else
		{
			bytes_to_transfer = 128 - uart_rx_ring_read_pos;
     648:	70 e0       	ldi	r23, 0x00	; 0
		}
		/* Write the received data to the endpoint */
		Endpoint_Write_Stream_LE(uart_rx_ring_buffer + uart_rx_ring_read_pos, bytes_to_transfer, NULL);
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	40 e0       	ldi	r20, 0x00	; 0
     64e:	50 e0       	ldi	r21, 0x00	; 0
     650:	81 5f       	subi	r24, 0xF1	; 241
     652:	9d 4d       	sbci	r25, 0xDD	; 221
     654:	e6 d1       	rcall	.+972    	; 0xa22 <Endpoint_Write_Stream_LE>
     656:	80 91 0a 20 	lds	r24, 0x200A	; 0x80200a <uart_rx_ring_read_pos>
		uart_rx_ring_read_pos = (uart_rx_ring_read_pos + bytes_to_transfer) & 0b1111111;
     65a:	c8 0f       	add	r28, r24
     65c:	cf 77       	andi	r28, 0x7F	; 127
     65e:	c0 93 0a 20 	sts	0x200A, r28	; 0x80200a <uart_rx_ring_read_pos>

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();
     662:	c8 d3       	rcall	.+1936   	; 0xdf4 <Endpoint_ClearIN>
     664:	32 d5       	rcall	.+2660   	; 0x10ca <Endpoint_WaitUntilReady>

		/* Wait until the endpoint is ready for the next packet */
		Endpoint_WaitUntilReady();
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28

		/* Send an empty packet to prevent host buffering */
		Endpoint_ClearIN();
	}
}
     66a:	c4 c3       	rjmp	.+1928   	; 0xdf4 <Endpoint_ClearIN>
     66c:	df 91       	pop	r29

		/* Wait until the endpoint is ready for the next packet */
		Endpoint_WaitUntilReady();

		/* Send an empty packet to prevent host buffering */
		Endpoint_ClearIN();
     66e:	cf 91       	pop	r28
     670:	08 95       	ret

00000672 <main>:
	}
}
     672:	31 de       	rcall	.-926    	; 0x2d6 <SetupHardware>
     674:	ea de       	rcall	.-556    	; 0x44a <SetupUart>
     676:	fb de       	rcall	.-522    	; 0x46e <SetupAdditionalPins>
	SetupDebugUart();
#endif

	GlobalInterruptEnable();

	uart_rx_ring_buffer_init();
     678:	78 94       	sei
	uart_tx_buffer_init();
     67a:	77 de       	rcall	.-786    	; 0x36a <uart_rx_ring_buffer_init>
     67c:	a5 de       	rcall	.-694    	; 0x3c8 <uart_tx_buffer_init>

	for (;;)
	{
		CDC_Task();
     67e:	87 df       	rcall	.-242    	; 0x58e <CDC_Task>
     680:	bf d1       	rcall	.+894    	; 0xa00 <USB_USBTask>
		USB_USBTask();
     682:	fd cf       	rjmp	.-6      	; 0x67e <main+0xc>

00000684 <__vector_8>:
     684:	1f 92       	push	r1
     686:	0f 92       	push	r0
	}
}

//DMA Interrupts
ISR(DMA_CH2_vect)
{
     688:	0f b6       	in	r0, 0x3f	; 63
     68a:	0f 92       	push	r0
     68c:	11 24       	eor	r1, r1
     68e:	08 b6       	in	r0, 0x38	; 56
     690:	0f 92       	push	r0
     692:	18 be       	out	0x38, r1	; 56
     694:	0b b6       	in	r0, 0x3b	; 59
     696:	0f 92       	push	r0
     698:	1b be       	out	0x3b, r1	; 59
     69a:	8f 93       	push	r24
     69c:	ef 93       	push	r30
     69e:	ff 93       	push	r31
	DMA.CH2.CTRLB |= DMA_CH_TRNIF_bm;
     6a0:	e0 e0       	ldi	r30, 0x00	; 0
     6a2:	f1 e0       	ldi	r31, 0x01	; 1
     6a4:	81 a9       	ldd	r24, Z+49	; 0x31
     6a6:	80 61       	ori	r24, 0x10	; 16
     6a8:	81 ab       	std	Z+49, r24	; 0x31
}
     6aa:	ff 91       	pop	r31
     6ac:	ef 91       	pop	r30
     6ae:	8f 91       	pop	r24
     6b0:	0f 90       	pop	r0
     6b2:	0b be       	out	0x3b, r0	; 59
     6b4:	0f 90       	pop	r0
     6b6:	08 be       	out	0x38, r0	; 56
     6b8:	0f 90       	pop	r0
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	0f 90       	pop	r0
     6be:	1f 90       	pop	r1
     6c0:	18 95       	reti

000006c2 <__vector_7>:

ISR(DMA_CH1_vect)
{
     6c2:	1f 92       	push	r1
     6c4:	0f 92       	push	r0
     6c6:	0f b6       	in	r0, 0x3f	; 63
     6c8:	0f 92       	push	r0
     6ca:	11 24       	eor	r1, r1
     6cc:	08 b6       	in	r0, 0x38	; 56
     6ce:	0f 92       	push	r0
     6d0:	18 be       	out	0x38, r1	; 56
     6d2:	09 b6       	in	r0, 0x39	; 57
     6d4:	0f 92       	push	r0
     6d6:	19 be       	out	0x39, r1	; 57
     6d8:	0b b6       	in	r0, 0x3b	; 59
     6da:	0f 92       	push	r0
     6dc:	1b be       	out	0x3b, r1	; 59
     6de:	2f 93       	push	r18
     6e0:	3f 93       	push	r19
     6e2:	4f 93       	push	r20
     6e4:	5f 93       	push	r21
     6e6:	6f 93       	push	r22
     6e8:	7f 93       	push	r23
     6ea:	8f 93       	push	r24
     6ec:	9f 93       	push	r25
     6ee:	af 93       	push	r26
     6f0:	bf 93       	push	r27
     6f2:	ef 93       	push	r30
     6f4:	ff 93       	push	r31
	DMA.CH1.CTRLB |= DMA_CH_TRNIF_bm;
     6f6:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x7de121>
     6fa:	80 61       	ori	r24, 0x10	; 16
     6fc:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x7de121>

	uart_tx_buffer_dma_pos = (uart_tx_buffer_dma_pos + 1) &0b11;
     700:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     704:	8f 5f       	subi	r24, 0xFF	; 255
     706:	83 70       	andi	r24, 0x03	; 3
     708:	80 93 09 20 	sts	0x2009, r24	; 0x802009 <uart_tx_buffer_dma_pos>
	if(uart_tx_buffer_dma_pos != uart_tx_buffer_usb_pos)
     70c:	90 91 09 20 	lds	r25, 0x2009	; 0x802009 <uart_tx_buffer_dma_pos>
     710:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <__data_end>
     714:	98 17       	cp	r25, r24
     716:	11 f0       	breq	.+4      	; 0x71c <__vector_7+0x5a>
	{
		uart_tx_dma_transfer_init();
     718:	6b de       	rcall	.-810    	; 0x3f0 <uart_tx_dma_transfer_init>
     71a:	03 c0       	rjmp	.+6      	; 0x722 <__vector_7+0x60>
	}
	else
	{
		dma_ready = true;
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
	}
}
     722:	ff 91       	pop	r31
     724:	ef 91       	pop	r30
     726:	bf 91       	pop	r27
     728:	af 91       	pop	r26
     72a:	9f 91       	pop	r25
     72c:	8f 91       	pop	r24
     72e:	7f 91       	pop	r23
     730:	6f 91       	pop	r22
     732:	5f 91       	pop	r21
     734:	4f 91       	pop	r20
     736:	3f 91       	pop	r19
     738:	2f 91       	pop	r18
     73a:	0f 90       	pop	r0
     73c:	0b be       	out	0x3b, r0	; 59
     73e:	0f 90       	pop	r0
     740:	09 be       	out	0x39, r0	; 57
     742:	0f 90       	pop	r0
     744:	08 be       	out	0x38, r0	; 56
     746:	0f 90       	pop	r0
     748:	0f be       	out	0x3f, r0	; 63
     74a:	0f 90       	pop	r0
     74c:	1f 90       	pop	r1
     74e:	18 95       	reti

00000750 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     750:	29 2f       	mov	r18, r25
     752:	33 27       	eor	r19, r19
     754:	22 30       	cpi	r18, 0x02	; 2
     756:	31 05       	cpc	r19, r1
     758:	59 f0       	breq	.+22     	; 0x770 <CALLBACK_USB_GetDescriptor+0x20>
     75a:	23 30       	cpi	r18, 0x03	; 3
     75c:	31 05       	cpc	r19, r1
     75e:	69 f0       	breq	.+26     	; 0x77a <CALLBACK_USB_GetDescriptor+0x2a>
     760:	21 30       	cpi	r18, 0x01	; 1
     762:	31 05       	cpc	r19, r1
     764:	e9 f4       	brne	.+58     	; 0x7a0 <CALLBACK_USB_GetDescriptor+0x50>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     766:	82 e1       	ldi	r24, 0x12	; 18
     768:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     76a:	28 e7       	ldi	r18, 0x78	; 120
     76c:	32 e0       	ldi	r19, 0x02	; 2
     76e:	1c c0       	rjmp	.+56     	; 0x7a8 <CALLBACK_USB_GetDescriptor+0x58>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     770:	8e e3       	ldi	r24, 0x3E	; 62
     772:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     774:	2a e3       	ldi	r18, 0x3A	; 58
     776:	32 e0       	ldi	r19, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     778:	17 c0       	rjmp	.+46     	; 0x7a8 <CALLBACK_USB_GetDescriptor+0x58>
		case DTYPE_String:
			switch (DescriptorNumber)
     77a:	99 27       	eor	r25, r25
     77c:	81 30       	cpi	r24, 0x01	; 1
     77e:	91 05       	cpc	r25, r1
     780:	49 f0       	breq	.+18     	; 0x794 <CALLBACK_USB_GetDescriptor+0x44>
     782:	28 f0       	brcs	.+10     	; 0x78e <CALLBACK_USB_GetDescriptor+0x3e>
     784:	02 97       	sbiw	r24, 0x02	; 2
     786:	61 f4       	brne	.+24     	; 0x7a0 <CALLBACK_USB_GetDescriptor+0x50>
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     788:	ec ef       	ldi	r30, 0xFC	; 252
     78a:	f1 e0       	ldi	r31, 0x01	; 1
     78c:	05 c0       	rjmp	.+10     	; 0x798 <CALLBACK_USB_GetDescriptor+0x48>
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     78e:	e6 e3       	ldi	r30, 0x36	; 54
     790:	f2 e0       	ldi	r31, 0x02	; 2
     792:	02 c0       	rjmp	.+4      	; 0x798 <CALLBACK_USB_GetDescriptor+0x48>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     794:	ea e1       	ldi	r30, 0x1A	; 26
     796:	f2 e0       	ldi	r31, 0x02	; 2
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     798:	84 91       	lpm	r24, Z
     79a:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
     79c:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
     79e:	04 c0       	rjmp	.+8      	; 0x7a8 <CALLBACK_USB_GetDescriptor+0x58>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     7a8:	fa 01       	movw	r30, r20
     7aa:	20 83       	st	Z, r18
     7ac:	31 83       	std	Z+1, r19	; 0x01
	return Size;
}
     7ae:	08 95       	ret

000007b0 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
     7b0:	0f 93       	push	r16
     7b2:	1f 93       	push	r17
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	ea 97       	sbiw	r28, 0x3a	; 58
     7be:	cd bf       	out	0x3d, r28	; 61
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	04 e9       	ldi	r16, 0x94	; 148
     7c4:	12 e2       	ldi	r17, 0x22	; 34
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
     7c6:	3e d3       	rcall	.+1660   	; 0xe44 <Endpoint_Read_8>
     7c8:	f8 01       	movw	r30, r16
     7ca:	81 93       	st	Z+, r24
     7cc:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
     7ce:	f2 e2       	ldi	r31, 0x22	; 34
     7d0:	0c 39       	cpi	r16, 0x9C	; 156
     7d2:	1f 07       	cpc	r17, r31
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
     7d4:	c1 f7       	brne	.-16     	; 0x7c6 <USB_Device_ProcessControlRequest+0x16>

	if (Endpoint_IsSETUPReceived())
     7d6:	6c de       	rcall	.-808    	; 0x4b0 <EVENT_USB_Device_ControlRequest>
     7d8:	b0 d3       	rcall	.+1888   	; 0xf3a <Endpoint_IsSETUPReceived>
     7da:	88 23       	and	r24, r24
     7dc:	09 f4       	brne	.+2      	; 0x7e0 <USB_Device_ProcessControlRequest+0x30>
     7de:	02 c1       	rjmp	.+516    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
     7e0:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <USB_ControlRequest>

		switch (USB_ControlRequest.bRequest)
     7e4:	90 91 95 22 	lds	r25, 0x2295	; 0x802295 <USB_ControlRequest+0x1>
     7e8:	95 30       	cpi	r25, 0x05	; 5
     7ea:	09 f4       	brne	.+2      	; 0x7ee <USB_Device_ProcessControlRequest+0x3e>
     7ec:	78 c0       	rjmp	.+240    	; 0x8de <__EEPROM_REGION_LENGTH__+0xde>
     7ee:	30 f4       	brcc	.+12     	; 0x7fc <USB_Device_ProcessControlRequest+0x4c>
     7f0:	91 30       	cpi	r25, 0x01	; 1
     7f2:	91 f1       	breq	.+100    	; 0x858 <__EEPROM_REGION_LENGTH__+0x58>
     7f4:	68 f0       	brcs	.+26     	; 0x810 <__EEPROM_REGION_LENGTH__+0x10>
     7f6:	93 30       	cpi	r25, 0x03	; 3
     7f8:	79 f1       	breq	.+94     	; 0x858 <__EEPROM_REGION_LENGTH__+0x58>
     7fa:	f4 c0       	rjmp	.+488    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     7fc:	98 30       	cpi	r25, 0x08	; 8
     7fe:	09 f4       	brne	.+2      	; 0x802 <__EEPROM_REGION_LENGTH__+0x2>
     800:	cc c0       	rjmp	.+408    	; 0x99a <__EEPROM_REGION_LENGTH__+0x19a>
     802:	99 30       	cpi	r25, 0x09	; 9
     804:	09 f4       	brne	.+2      	; 0x808 <__EEPROM_REGION_LENGTH__+0x8>
     806:	d1 c0       	rjmp	.+418    	; 0x9aa <__EEPROM_REGION_LENGTH__+0x1aa>
     808:	96 30       	cpi	r25, 0x06	; 6
     80a:	09 f0       	breq	.+2      	; 0x80e <__EEPROM_REGION_LENGTH__+0xe>
     80c:	eb c0       	rjmp	.+470    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     80e:	7b c0       	rjmp	.+246    	; 0x906 <__EEPROM_REGION_LENGTH__+0x106>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     810:	80 38       	cpi	r24, 0x80	; 128
     812:	21 f0       	breq	.+8      	; 0x81c <__EEPROM_REGION_LENGTH__+0x1c>
     814:	82 38       	cpi	r24, 0x82	; 130
     816:	09 f0       	breq	.+2      	; 0x81a <__EEPROM_REGION_LENGTH__+0x1a>
     818:	e5 c0       	rjmp	.+458    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     81a:	08 c0       	rjmp	.+16     	; 0x82c <__EEPROM_REGION_LENGTH__+0x2c>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
     81c:	10 91 90 22 	lds	r17, 0x2290	; 0x802290 <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
     820:	80 91 91 22 	lds	r24, 0x2291	; 0x802291 <USB_Device_RemoteWakeupEnabled>
     824:	88 23       	and	r24, r24
     826:	99 f0       	breq	.+38     	; 0x84e <__EEPROM_REGION_LENGTH__+0x4e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
     828:	12 60       	ori	r17, 0x02	; 2
     82a:	11 c0       	rjmp	.+34     	; 0x84e <__EEPROM_REGION_LENGTH__+0x4e>
			break;
		}
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
		{
			#if !defined(CONTROL_ONLY_DEVICE)
			uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
     82c:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <USB_ControlRequest+0x4>
     830:	8f 70       	andi	r24, 0x0F	; 15

			if (EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
     832:	85 30       	cpi	r24, 0x05	; 5
     834:	08 f0       	brcs	.+2      	; 0x838 <__EEPROM_REGION_LENGTH__+0x38>
				return;

			Endpoint_SelectEndpoint(EndpointIndex);
     836:	d6 c0       	rjmp	.+428    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     838:	25 d3       	rcall	.+1610   	; 0xe84 <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
     83a:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     83e:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     842:	11 81       	ldd	r17, Z+1	; 0x01

			CurrentStatus = Endpoint_IsStalled();
     844:	12 fb       	bst	r17, 2

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
     846:	11 27       	eor	r17, r17
     848:	10 f9       	bld	r17, 0
		}
		default:
			return;
	}

	Endpoint_ClearSETUP();
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	1b d3       	rcall	.+1590   	; 0xe84 <Endpoint_SelectEndpoint>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
     84e:	8f d3       	rcall	.+1822   	; 0xf6e <Endpoint_ClearSETUP>
     850:	81 2f       	mov	r24, r17
     852:	08 d3       	rcall	.+1552   	; 0xe64 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	a6 c0       	rjmp	.+332    	; 0x9a4 <__EEPROM_REGION_LENGTH__+0x1a4>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     858:	28 2f       	mov	r18, r24
     85a:	2d 7f       	andi	r18, 0xFD	; 253
     85c:	09 f0       	breq	.+2      	; 0x860 <__EEPROM_REGION_LENGTH__+0x60>
     85e:	c2 c0       	rjmp	.+388    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
     860:	88 23       	and	r24, r24
     862:	19 f0       	breq	.+6      	; 0x86a <__EEPROM_REGION_LENGTH__+0x6a>
     864:	82 30       	cpi	r24, 0x02	; 2
     866:	61 f0       	breq	.+24     	; 0x880 <__EEPROM_REGION_LENGTH__+0x80>
     868:	bd c0       	rjmp	.+378    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
     86a:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>
     86e:	81 30       	cpi	r24, 0x01	; 1
     870:	09 f0       	breq	.+2      	; 0x874 <__EEPROM_REGION_LENGTH__+0x74>
     872:	b8 c0       	rjmp	.+368    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
     874:	93 30       	cpi	r25, 0x03	; 3
     876:	09 f0       	breq	.+2      	; 0x87a <__EEPROM_REGION_LENGTH__+0x7a>
     878:	80 e0       	ldi	r24, 0x00	; 0
     87a:	80 93 91 22 	sts	0x2291, r24	; 0x802291 <USB_Device_RemoteWakeupEnabled>
     87e:	2a c0       	rjmp	.+84     	; 0x8d4 <__EEPROM_REGION_LENGTH__+0xd4>
		}
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
     880:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>
     884:	81 11       	cpse	r24, r1
     886:	26 c0       	rjmp	.+76     	; 0x8d4 <__EEPROM_REGION_LENGTH__+0xd4>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
     888:	e0 91 98 22 	lds	r30, 0x2298	; 0x802298 <USB_ControlRequest+0x4>
     88c:	1e 2f       	mov	r17, r30

				if (EndpointIndex == ENDPOINT_CONTROLEP || EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
     88e:	1f 70       	andi	r17, 0x0F	; 15
     890:	8f ef       	ldi	r24, 0xFF	; 255
     892:	81 0f       	add	r24, r17
     894:	84 30       	cpi	r24, 0x04	; 4
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
     896:	08 f0       	brcs	.+2      	; 0x89a <__EEPROM_REGION_LENGTH__+0x9a>
     898:	a5 c0       	rjmp	.+330    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     89a:	81 2f       	mov	r24, r17

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
     89c:	f3 d2       	rcall	.+1510   	; 0xe84 <Endpoint_SelectEndpoint>
     89e:	80 91 95 22 	lds	r24, 0x2295	; 0x802295 <USB_ControlRequest+0x1>
     8a2:	83 30       	cpi	r24, 0x03	; 3
					{
						Endpoint_StallTransaction();
     8a4:	11 f4       	brne	.+4      	; 0x8aa <__EEPROM_REGION_LENGTH__+0xaa>
     8a6:	8f d3       	rcall	.+1822   	; 0xfc6 <Endpoint_StallTransaction>
     8a8:	15 c0       	rjmp	.+42     	; 0x8d4 <__EEPROM_REGION_LENGTH__+0xd4>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
     8aa:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     8ae:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     8b2:	81 81       	ldd	r24, Z+1	; 0x01
     8b4:	8b 7f       	andi	r24, 0xFB	; 251
     8b6:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
     8b8:	24 e8       	ldi	r18, 0x84	; 132
     8ba:	12 9f       	mul	r17, r18
     8bc:	f0 01       	movw	r30, r0
     8be:	11 24       	eor	r1, r1
     8c0:	ee 51       	subi	r30, 0x1E	; 30
     8c2:	fd 4d       	sbci	r31, 0xDD	; 221

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
     8c4:	10 82       	st	Z, r1
     8c6:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     8ca:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
     8ce:	80 81       	ld	r24, Z
     8d0:	8e 7f       	andi	r24, 0xFE	; 254

	Endpoint_ClearSETUP();
     8d2:	80 83       	st	Z, r24

	Endpoint_ClearStatusStage();
     8d4:	80 e0       	ldi	r24, 0x00	; 0
     8d6:	d6 d2       	rcall	.+1452   	; 0xe84 <Endpoint_SelectEndpoint>
     8d8:	4a d3       	rcall	.+1684   	; 0xf6e <Endpoint_ClearSETUP>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     8da:	e1 d3       	rcall	.+1986   	; 0x109e <Endpoint_ClearStatusStage>
     8dc:	83 c0       	rjmp	.+262    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
     8de:	81 11       	cpse	r24, r1
     8e0:	81 c0       	rjmp	.+258    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     8e2:	10 91 96 22 	lds	r17, 0x2296	; 0x802296 <USB_ControlRequest+0x2>

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
     8e6:	1f 77       	andi	r17, 0x7F	; 127

	Endpoint_ClearStatusStage();
     8e8:	42 d3       	rcall	.+1668   	; 0xf6e <Endpoint_ClearSETUP>
     8ea:	d9 d3       	rcall	.+1970   	; 0x109e <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
     8ec:	00 d3       	rcall	.+1536   	; 0xeee <Endpoint_IsINReady>
     8ee:	88 23       	and	r24, r24
     8f0:	e9 f3       	breq	.-6      	; 0x8ec <__EEPROM_REGION_LENGTH__+0xec>
     8f2:	10 93 c3 04 	sts	0x04C3, r17	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7de4c3>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
     8f6:	11 11       	cpse	r17, r1

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
     8f8:	02 c0       	rjmp	.+4      	; 0x8fe <__EEPROM_REGION_LENGTH__+0xfe>
     8fa:	82 e0       	ldi	r24, 0x02	; 2
     8fc:	01 c0       	rjmp	.+2      	; 0x900 <__EEPROM_REGION_LENGTH__+0x100>
     8fe:	83 e0       	ldi	r24, 0x03	; 3
     900:	80 93 93 22 	sts	0x2293, r24	; 0x802293 <USB_DeviceState>
     904:	6f c0       	rjmp	.+222    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     906:	80 58       	subi	r24, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     908:	82 30       	cpi	r24, 0x02	; 2
     90a:	08 f0       	brcs	.+2      	; 0x90e <__EEPROM_REGION_LENGTH__+0x10e>
     90c:	6b c0       	rjmp	.+214    	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     90e:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
     912:	90 91 97 22 	lds	r25, 0x2297	; 0x802297 <USB_ControlRequest+0x3>
     916:	8c 3d       	cpi	r24, 0xDC	; 220
     918:	e3 e0       	ldi	r30, 0x03	; 3
     91a:	9e 07       	cpc	r25, r30
     91c:	61 f5       	brne	.+88     	; 0x976 <__EEPROM_REGION_LENGTH__+0x176>
     91e:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
     920:	8a 83       	std	Y+2, r24	; 0x02
     922:	8a e3       	ldi	r24, 0x3A	; 58
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
     924:	89 83       	std	Y+1, r24	; 0x01
     926:	4f b7       	in	r20, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
     928:	f8 94       	cli
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
     92a:	de 01       	movw	r26, r28
				#endif

				GCC_MEMORY_BARRIER();
     92c:	13 96       	adiw	r26, 0x03	; 3
     92e:	20 e0       	ldi	r18, 0x00	; 0
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     930:	38 e0       	ldi	r19, 0x08	; 8
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
     932:	52 e0       	ldi	r21, 0x02	; 2

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
     934:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7de1ca>
     938:	e3 2f       	mov	r30, r19
					SerialByte = pgm_read_byte(SigReadAddress);
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	e4 91       	lpm	r30, Z
     93e:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7de1ca>
					NVM.CMD    = 0;
     942:	20 ff       	sbrs	r18, 0

					if (SerialCharNum & 0x01)
     944:	03 c0       	rjmp	.+6      	; 0x94c <__EEPROM_REGION_LENGTH__+0x14c>
     946:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
     948:	ef 70       	andi	r30, 0x0F	; 15
     94a:	3f 5f       	subi	r19, 0xFF	; 255
						SigReadAddress++;
					}

					SerialByte &= 0x0F;
     94c:	ef 70       	andi	r30, 0x0F	; 15
     94e:	8e 2f       	mov	r24, r30
     950:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
     952:	ea 30       	cpi	r30, 0x0A	; 10
     954:	10 f0       	brcs	.+4      	; 0x95a <__EEPROM_REGION_LENGTH__+0x15a>
     956:	c7 96       	adiw	r24, 0x37	; 55
     958:	01 c0       	rjmp	.+2      	; 0x95c <__EEPROM_REGION_LENGTH__+0x15c>
     95a:	c0 96       	adiw	r24, 0x30	; 48
     95c:	8d 93       	st	X+, r24
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     95e:	9d 93       	st	X+, r25
     960:	2f 5f       	subi	r18, 0xFF	; 255
     962:	2c 31       	cpi	r18, 0x1C	; 28

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
     964:	39 f7       	brne	.-50     	; 0x934 <__EEPROM_REGION_LENGTH__+0x134>
     966:	4f bf       	out	0x3f, r20	; 63

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
     968:	02 d3       	rcall	.+1540   	; 0xf6e <Endpoint_ClearSETUP>
     96a:	6a e3       	ldi	r22, 0x3A	; 58
     96c:	70 e0       	ldi	r23, 0x00	; 0
     96e:	ce 01       	movw	r24, r28
     970:	01 96       	adiw	r24, 0x01	; 1
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
     972:	f1 d0       	rcall	.+482    	; 0xb56 <Endpoint_Write_Control_Stream_LE>
     974:	10 c0       	rjmp	.+32     	; 0x996 <__EEPROM_REGION_LENGTH__+0x196>
     976:	60 91 98 22 	lds	r22, 0x2298	; 0x802298 <USB_ControlRequest+0x4>
     97a:	70 91 99 22 	lds	r23, 0x2299	; 0x802299 <USB_ControlRequest+0x5>
     97e:	ae 01       	movw	r20, r28
     980:	4f 5f       	subi	r20, 0xFF	; 255
     982:	5f 4f       	sbci	r21, 0xFF	; 255
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
     984:	e5 de       	rcall	.-566    	; 0x750 <CALLBACK_USB_GetDescriptor>
     986:	8c 01       	movw	r16, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
     988:	89 2b       	or	r24, r25
     98a:	61 f1       	breq	.+88     	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     98c:	f0 d2       	rcall	.+1504   	; 0xf6e <Endpoint_ClearSETUP>
     98e:	b8 01       	movw	r22, r16
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
     990:	89 81       	ldd	r24, Y+1	; 0x01
     992:	9a 81       	ldd	r25, Y+2	; 0x02
     994:	b1 d1       	rcall	.+866    	; 0xcf8 <Endpoint_Write_Control_PStream_LE>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
     996:	47 d2       	rcall	.+1166   	; 0xe26 <Endpoint_ClearOUT>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
     998:	25 c0       	rjmp	.+74     	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     99a:	80 38       	cpi	r24, 0x80	; 128

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
     99c:	19 f5       	brne	.+70     	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     99e:	e7 d2       	rcall	.+1486   	; 0xf6e <Endpoint_ClearSETUP>
     9a0:	80 91 8f 22 	lds	r24, 0x228F	; 0x80228f <USB_Device_ConfigurationNumber>
	Endpoint_ClearIN();
     9a4:	5f d2       	rcall	.+1214   	; 0xe64 <Endpoint_Write_8>
     9a6:	26 d2       	rcall	.+1100   	; 0xdf4 <Endpoint_ClearIN>
     9a8:	98 cf       	rjmp	.-208    	; 0x8da <__EEPROM_REGION_LENGTH__+0xda>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     9aa:	81 11       	cpse	r24, r1
     9ac:	1b c0       	rjmp	.+54     	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
     9ae:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>
     9b2:	90 91 97 22 	lds	r25, 0x2297	; 0x802297 <USB_ControlRequest+0x3>
     9b6:	99 27       	eor	r25, r25
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
     9b8:	02 97       	sbiw	r24, 0x02	; 2

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
     9ba:	a4 f4       	brge	.+40     	; 0x9e4 <__EEPROM_REGION_LENGTH__+0x1e4>
     9bc:	d8 d2       	rcall	.+1456   	; 0xf6e <Endpoint_ClearSETUP>
     9be:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <USB_ControlRequest+0x2>

	Endpoint_ClearStatusStage();
     9c2:	80 93 8f 22 	sts	0x228F, r24	; 0x80228f <USB_Device_ConfigurationNumber>

	if (USB_Device_ConfigurationNumber)
     9c6:	6b d3       	rcall	.+1750   	; 0x109e <Endpoint_ClearStatusStage>
     9c8:	80 91 8f 22 	lds	r24, 0x228F	; 0x80228f <USB_Device_ConfigurationNumber>
     9cc:	81 11       	cpse	r24, r1
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
     9ce:	06 c0       	rjmp	.+12     	; 0x9dc <__EEPROM_REGION_LENGTH__+0x1dc>
     9d0:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7de4c3>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
     9d4:	81 11       	cpse	r24, r1
     9d6:	02 c0       	rjmp	.+4      	; 0x9dc <__EEPROM_REGION_LENGTH__+0x1dc>
     9d8:	81 e0       	ldi	r24, 0x01	; 1
     9da:	01 c0       	rjmp	.+2      	; 0x9de <__EEPROM_REGION_LENGTH__+0x1de>
     9dc:	84 e0       	ldi	r24, 0x04	; 4
     9de:	80 93 93 22 	sts	0x2293, r24	; 0x802293 <USB_DeviceState>

	EVENT_USB_Device_ConfigurationChanged();
     9e2:	51 dd       	rcall	.-1374   	; 0x486 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
     9e4:	aa d2       	rcall	.+1364   	; 0xf3a <Endpoint_IsSETUPReceived>
     9e6:	88 23       	and	r24, r24
     9e8:	11 f0       	breq	.+4      	; 0x9ee <__EEPROM_REGION_LENGTH__+0x1ee>
     9ea:	c1 d2       	rcall	.+1410   	; 0xf6e <Endpoint_ClearSETUP>
	{
		Endpoint_ClearSETUP();
     9ec:	ec d2       	rcall	.+1496   	; 0xfc6 <Endpoint_StallTransaction>
     9ee:	ea 96       	adiw	r28, 0x3a	; 58
		Endpoint_StallTransaction();
     9f0:	cd bf       	out	0x3d, r28	; 61
     9f2:	de bf       	out	0x3e, r29	; 62
	}
}
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	1f 91       	pop	r17
     9fa:	0f 91       	pop	r16
     9fc:	08 95       	ret

000009fe <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
     9fe:	08 95       	ret

00000a00 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
     a00:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
     a02:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     a06:	88 23       	and	r24, r24
     a08:	51 f0       	breq	.+20     	; 0xa1e <USB_USBTask+0x1e>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
     a0a:	c0 91 a0 22 	lds	r28, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	39 d2       	rcall	.+1138   	; 0xe84 <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
     a12:	93 d2       	rcall	.+1318   	; 0xf3a <Endpoint_IsSETUPReceived>
     a14:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
     a16:	cc de       	rcall	.-616    	; 0x7b0 <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
     a18:	8c 2f       	mov	r24, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
     a1a:	cf 91       	pop	r28
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
	  USB_Device_ProcessControlRequest();

	Endpoint_SelectEndpoint(PrevEndpoint);
     a1c:	33 c2       	rjmp	.+1126   	; 0xe84 <Endpoint_SelectEndpoint>
     a1e:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
     a20:	08 95       	ret

00000a22 <Endpoint_Write_Stream_LE>:
     a22:	cf 92       	push	r12
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
     a24:	df 92       	push	r13
     a26:	ef 92       	push	r14
     a28:	ff 92       	push	r15
     a2a:	0f 93       	push	r16
     a2c:	1f 93       	push	r17
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	ec 01       	movw	r28, r24
     a34:	8b 01       	movw	r16, r22
     a36:	7a 01       	movw	r14, r20
     a38:	48 d3       	rcall	.+1680   	; 0x10ca <Endpoint_WaitUntilReady>
     a3a:	81 11       	cpse	r24, r1
     a3c:	36 c0       	rjmp	.+108    	; 0xaaa <Endpoint_Write_Stream_LE+0x88>
     a3e:	e1 14       	cp	r14, r1
     a40:	f1 04       	cpc	r15, r1
     a42:	39 f0       	breq	.+14     	; 0xa52 <Endpoint_Write_Stream_LE+0x30>
     a44:	f7 01       	movw	r30, r14
     a46:	80 81       	ld	r24, Z
     a48:	91 81       	ldd	r25, Z+1	; 0x01
     a4a:	08 1b       	sub	r16, r24
     a4c:	19 0b       	sbc	r17, r25
     a4e:	c8 0f       	add	r28, r24
     a50:	d9 1f       	adc	r29, r25
     a52:	c1 2c       	mov	r12, r1
     a54:	d1 2c       	mov	r13, r1
     a56:	01 15       	cp	r16, r1
     a58:	11 05       	cpc	r17, r1
     a5a:	31 f1       	breq	.+76     	; 0xaa8 <Endpoint_Write_Stream_LE+0x86>
     a5c:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     a60:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     a64:	fc 01       	movw	r30, r24
     a66:	ef 5b       	subi	r30, 0xBF	; 191
     a68:	ff 4f       	sbci	r31, 0xFF	; 255
     a6a:	20 81       	ld	r18, Z
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	80 81       	ld	r24, Z
     a70:	28 17       	cp	r18, r24
     a72:	90 f0       	brcs	.+36     	; 0xa98 <Endpoint_Write_Stream_LE+0x76>
     a74:	bf d1       	rcall	.+894    	; 0xdf4 <Endpoint_ClearIN>
     a76:	c4 df       	rcall	.-120    	; 0xa00 <USB_USBTask>
     a78:	e1 14       	cp	r14, r1
     a7a:	f1 04       	cpc	r15, r1
     a7c:	49 f0       	breq	.+18     	; 0xa90 <Endpoint_Write_Stream_LE+0x6e>
     a7e:	f7 01       	movw	r30, r14
     a80:	80 81       	ld	r24, Z
     a82:	91 81       	ldd	r25, Z+1	; 0x01
     a84:	c8 0e       	add	r12, r24
     a86:	d9 1e       	adc	r13, r25
     a88:	c0 82       	st	Z, r12
     a8a:	d1 82       	std	Z+1, r13	; 0x01
     a8c:	85 e0       	ldi	r24, 0x05	; 5
     a8e:	0d c0       	rjmp	.+26     	; 0xaaa <Endpoint_Write_Stream_LE+0x88>
     a90:	1c d3       	rcall	.+1592   	; 0x10ca <Endpoint_WaitUntilReady>
     a92:	88 23       	and	r24, r24
     a94:	01 f3       	breq	.-64     	; 0xa56 <Endpoint_Write_Stream_LE+0x34>
     a96:	09 c0       	rjmp	.+18     	; 0xaaa <Endpoint_Write_Stream_LE+0x88>
     a98:	89 91       	ld	r24, Y+
     a9a:	e4 d1       	rcall	.+968    	; 0xe64 <Endpoint_Write_8>
     a9c:	01 50       	subi	r16, 0x01	; 1
     a9e:	11 09       	sbc	r17, r1
     aa0:	ff ef       	ldi	r31, 0xFF	; 255
     aa2:	cf 1a       	sub	r12, r31
     aa4:	df 0a       	sbc	r13, r31
     aa6:	d7 cf       	rjmp	.-82     	; 0xa56 <Endpoint_Write_Stream_LE+0x34>
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	cf 90       	pop	r12
     aba:	08 95       	ret

00000abc <Endpoint_Read_Stream_LE>:
     abc:	cf 92       	push	r12
     abe:	df 92       	push	r13
     ac0:	ef 92       	push	r14
     ac2:	ff 92       	push	r15
     ac4:	0f 93       	push	r16
     ac6:	1f 93       	push	r17
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	ec 01       	movw	r28, r24
     ace:	8b 01       	movw	r16, r22
     ad0:	7a 01       	movw	r14, r20
     ad2:	fb d2       	rcall	.+1526   	; 0x10ca <Endpoint_WaitUntilReady>
     ad4:	81 11       	cpse	r24, r1
     ad6:	36 c0       	rjmp	.+108    	; 0xb44 <Endpoint_Read_Stream_LE+0x88>
     ad8:	e1 14       	cp	r14, r1
     ada:	f1 04       	cpc	r15, r1
     adc:	39 f0       	breq	.+14     	; 0xaec <Endpoint_Read_Stream_LE+0x30>
     ade:	f7 01       	movw	r30, r14
     ae0:	80 81       	ld	r24, Z
     ae2:	91 81       	ldd	r25, Z+1	; 0x01
     ae4:	08 1b       	sub	r16, r24
     ae6:	19 0b       	sbc	r17, r25
     ae8:	c8 0f       	add	r28, r24
     aea:	d9 1f       	adc	r29, r25
     aec:	c1 2c       	mov	r12, r1
     aee:	d1 2c       	mov	r13, r1
     af0:	01 15       	cp	r16, r1
     af2:	11 05       	cpc	r17, r1
     af4:	31 f1       	breq	.+76     	; 0xb42 <Endpoint_Read_Stream_LE+0x86>
     af6:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     afa:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     afe:	fc 01       	movw	r30, r24
     b00:	ef 5b       	subi	r30, 0xBF	; 191
     b02:	ff 4f       	sbci	r31, 0xFF	; 255
     b04:	20 81       	ld	r18, Z
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	80 81       	ld	r24, Z
     b0a:	28 17       	cp	r18, r24
     b0c:	90 f0       	brcs	.+36     	; 0xb32 <Endpoint_Read_Stream_LE+0x76>
     b0e:	8b d1       	rcall	.+790    	; 0xe26 <Endpoint_ClearOUT>
     b10:	77 df       	rcall	.-274    	; 0xa00 <USB_USBTask>
     b12:	e1 14       	cp	r14, r1
     b14:	f1 04       	cpc	r15, r1
     b16:	49 f0       	breq	.+18     	; 0xb2a <Endpoint_Read_Stream_LE+0x6e>
     b18:	f7 01       	movw	r30, r14
     b1a:	80 81       	ld	r24, Z
     b1c:	91 81       	ldd	r25, Z+1	; 0x01
     b1e:	c8 0e       	add	r12, r24
     b20:	d9 1e       	adc	r13, r25
     b22:	c0 82       	st	Z, r12
     b24:	d1 82       	std	Z+1, r13	; 0x01
     b26:	85 e0       	ldi	r24, 0x05	; 5
     b28:	0d c0       	rjmp	.+26     	; 0xb44 <Endpoint_Read_Stream_LE+0x88>
     b2a:	cf d2       	rcall	.+1438   	; 0x10ca <Endpoint_WaitUntilReady>
     b2c:	88 23       	and	r24, r24
     b2e:	01 f3       	breq	.-64     	; 0xaf0 <Endpoint_Read_Stream_LE+0x34>
     b30:	09 c0       	rjmp	.+18     	; 0xb44 <Endpoint_Read_Stream_LE+0x88>
     b32:	88 d1       	rcall	.+784    	; 0xe44 <Endpoint_Read_8>
     b34:	89 93       	st	Y+, r24
     b36:	01 50       	subi	r16, 0x01	; 1
     b38:	11 09       	sbc	r17, r1
     b3a:	ff ef       	ldi	r31, 0xFF	; 255
     b3c:	cf 1a       	sub	r12, r31
     b3e:	df 0a       	sbc	r13, r31
     b40:	d7 cf       	rjmp	.-82     	; 0xaf0 <Endpoint_Read_Stream_LE+0x34>
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	ff 90       	pop	r15
     b4e:	ef 90       	pop	r14
     b50:	df 90       	pop	r13
     b52:	cf 90       	pop	r12
     b54:	08 95       	ret

00000b56 <Endpoint_Write_Control_Stream_LE>:
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29
     b64:	d8 2f       	mov	r29, r24
     b66:	c9 2f       	mov	r28, r25
     b68:	8b 01       	movw	r16, r22
     b6a:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     b6e:	80 68       	ori	r24, 0x80	; 128
     b70:	89 d1       	rcall	.+786    	; 0xe84 <Endpoint_SelectEndpoint>
     b72:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <USB_ControlRequest+0x6>
     b76:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <USB_ControlRequest+0x7>
     b7a:	80 17       	cp	r24, r16
     b7c:	91 07       	cpc	r25, r17
     b7e:	28 f0       	brcs	.+10     	; 0xb8a <Endpoint_Write_Control_Stream_LE+0x34>
     b80:	01 15       	cp	r16, r1
     b82:	11 05       	cpc	r17, r1
     b84:	19 f4       	brne	.+6      	; 0xb8c <Endpoint_Write_Control_Stream_LE+0x36>
     b86:	36 d1       	rcall	.+620    	; 0xdf4 <Endpoint_ClearIN>
     b88:	01 c0       	rjmp	.+2      	; 0xb8c <Endpoint_Write_Control_Stream_LE+0x36>
     b8a:	8c 01       	movw	r16, r24
     b8c:	ed 2e       	mov	r14, r29
     b8e:	fc 2e       	mov	r15, r28
     b90:	d1 2c       	mov	r13, r1
     b92:	01 15       	cp	r16, r1
     b94:	11 05       	cpc	r17, r1
     b96:	09 f4       	brne	.+2      	; 0xb9a <Endpoint_Write_Control_Stream_LE+0x44>
     b98:	40 c0       	rjmp	.+128    	; 0xc1a <Endpoint_Write_Control_Stream_LE+0xc4>
     b9a:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     b9e:	81 11       	cpse	r24, r1
     ba0:	02 c0       	rjmp	.+4      	; 0xba6 <Endpoint_Write_Control_Stream_LE+0x50>
     ba2:	82 e0       	ldi	r24, 0x02	; 2
     ba4:	4c c0       	rjmp	.+152    	; 0xc3e <Endpoint_Write_Control_Stream_LE+0xe8>
     ba6:	85 30       	cpi	r24, 0x05	; 5
     ba8:	11 f4       	brne	.+4      	; 0xbae <Endpoint_Write_Control_Stream_LE+0x58>
     baa:	83 e0       	ldi	r24, 0x03	; 3
     bac:	48 c0       	rjmp	.+144    	; 0xc3e <Endpoint_Write_Control_Stream_LE+0xe8>
     bae:	c5 d1       	rcall	.+906    	; 0xf3a <Endpoint_IsSETUPReceived>
     bb0:	88 23       	and	r24, r24
     bb2:	11 f0       	breq	.+4      	; 0xbb8 <Endpoint_Write_Control_Stream_LE+0x62>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	43 c0       	rjmp	.+134    	; 0xc3e <Endpoint_Write_Control_Stream_LE+0xe8>
     bb8:	a6 d1       	rcall	.+844    	; 0xf06 <Endpoint_IsOUTReceived>
     bba:	81 11       	cpse	r24, r1
     bbc:	3c c0       	rjmp	.+120    	; 0xc36 <Endpoint_Write_Control_Stream_LE+0xe0>
     bbe:	97 d1       	rcall	.+814    	; 0xeee <Endpoint_IsINReady>
     bc0:	88 23       	and	r24, r24
     bc2:	39 f3       	breq	.-50     	; 0xb92 <Endpoint_Write_Control_Stream_LE+0x3c>
     bc4:	20 91 a0 22 	lds	r18, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     bc8:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     bcc:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     bd0:	fc 01       	movw	r30, r24
     bd2:	27 ff       	sbrs	r18, 7
     bd4:	05 c0       	rjmp	.+10     	; 0xbe0 <Endpoint_Write_Control_Stream_LE+0x8a>
     bd6:	ef 5b       	subi	r30, 0xBF	; 191
     bd8:	ff 4f       	sbci	r31, 0xFF	; 255
     bda:	c0 81       	ld	r28, Z
     bdc:	d0 e0       	ldi	r29, 0x00	; 0
     bde:	13 c0       	rjmp	.+38     	; 0xc06 <Endpoint_Write_Control_Stream_LE+0xb0>
     be0:	e0 5c       	subi	r30, 0xC0	; 192
     be2:	ff 4f       	sbci	r31, 0xFF	; 255
     be4:	c0 81       	ld	r28, Z
     be6:	31 96       	adiw	r30, 0x01	; 1
     be8:	80 81       	ld	r24, Z
     bea:	d0 e0       	ldi	r29, 0x00	; 0
     bec:	c8 1b       	sub	r28, r24
     bee:	d1 09       	sbc	r29, r1
     bf0:	0a c0       	rjmp	.+20     	; 0xc06 <Endpoint_Write_Control_Stream_LE+0xb0>
     bf2:	c8 30       	cpi	r28, 0x08	; 8
     bf4:	d1 05       	cpc	r29, r1
     bf6:	50 f4       	brcc	.+20     	; 0xc0c <Endpoint_Write_Control_Stream_LE+0xb6>
     bf8:	f7 01       	movw	r30, r14
     bfa:	81 91       	ld	r24, Z+
     bfc:	7f 01       	movw	r14, r30
     bfe:	32 d1       	rcall	.+612    	; 0xe64 <Endpoint_Write_8>
     c00:	01 50       	subi	r16, 0x01	; 1
     c02:	11 09       	sbc	r17, r1
     c04:	21 96       	adiw	r28, 0x01	; 1
     c06:	01 15       	cp	r16, r1
     c08:	11 05       	cpc	r17, r1
     c0a:	99 f7       	brne	.-26     	; 0xbf2 <Endpoint_Write_Control_Stream_LE+0x9c>
     c0c:	dd 24       	eor	r13, r13
     c0e:	d3 94       	inc	r13
     c10:	28 97       	sbiw	r28, 0x08	; 8
     c12:	09 f0       	breq	.+2      	; 0xc16 <Endpoint_Write_Control_Stream_LE+0xc0>
     c14:	d1 2c       	mov	r13, r1
     c16:	ee d0       	rcall	.+476    	; 0xdf4 <Endpoint_ClearIN>
     c18:	bc cf       	rjmp	.-136    	; 0xb92 <Endpoint_Write_Control_Stream_LE+0x3c>
     c1a:	d1 10       	cpse	r13, r1
     c1c:	be cf       	rjmp	.-132    	; 0xb9a <Endpoint_Write_Control_Stream_LE+0x44>
     c1e:	0b c0       	rjmp	.+22     	; 0xc36 <Endpoint_Write_Control_Stream_LE+0xe0>
     c20:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     c24:	88 23       	and	r24, r24
     c26:	09 f4       	brne	.+2      	; 0xc2a <Endpoint_Write_Control_Stream_LE+0xd4>
     c28:	bc cf       	rjmp	.-136    	; 0xba2 <Endpoint_Write_Control_Stream_LE+0x4c>
     c2a:	85 30       	cpi	r24, 0x05	; 5
     c2c:	09 f4       	brne	.+2      	; 0xc30 <Endpoint_Write_Control_Stream_LE+0xda>
     c2e:	bd cf       	rjmp	.-134    	; 0xbaa <Endpoint_Write_Control_Stream_LE+0x54>
     c30:	84 d1       	rcall	.+776    	; 0xf3a <Endpoint_IsSETUPReceived>
     c32:	81 11       	cpse	r24, r1
     c34:	bf cf       	rjmp	.-130    	; 0xbb4 <Endpoint_Write_Control_Stream_LE+0x5e>
     c36:	67 d1       	rcall	.+718    	; 0xf06 <Endpoint_IsOUTReceived>
     c38:	88 23       	and	r24, r24
     c3a:	91 f3       	breq	.-28     	; 0xc20 <Endpoint_Write_Control_Stream_LE+0xca>
     c3c:	80 e0       	ldi	r24, 0x00	; 0
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	1f 91       	pop	r17
     c44:	0f 91       	pop	r16
     c46:	ff 90       	pop	r15
     c48:	ef 90       	pop	r14
     c4a:	df 90       	pop	r13
     c4c:	08 95       	ret

00000c4e <Endpoint_Read_Control_Stream_LE>:
     c4e:	ef 92       	push	r14
     c50:	ff 92       	push	r15
     c52:	0f 93       	push	r16
     c54:	1f 93       	push	r17
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
     c5a:	7c 01       	movw	r14, r24
     c5c:	eb 01       	movw	r28, r22
     c5e:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     c62:	8f 77       	andi	r24, 0x7F	; 127
     c64:	0f d1       	rcall	.+542    	; 0xe84 <Endpoint_SelectEndpoint>
     c66:	20 97       	sbiw	r28, 0x00	; 0
     c68:	09 f4       	brne	.+2      	; 0xc6c <Endpoint_Read_Control_Stream_LE+0x1e>
     c6a:	dd d0       	rcall	.+442    	; 0xe26 <Endpoint_ClearOUT>
     c6c:	87 01       	movw	r16, r14
     c6e:	20 97       	sbiw	r28, 0x00	; 0
     c70:	b1 f1       	breq	.+108    	; 0xcde <Endpoint_Read_Control_Stream_LE+0x90>
     c72:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     c76:	81 11       	cpse	r24, r1
     c78:	02 c0       	rjmp	.+4      	; 0xc7e <Endpoint_Read_Control_Stream_LE+0x30>
     c7a:	82 e0       	ldi	r24, 0x02	; 2
     c7c:	36 c0       	rjmp	.+108    	; 0xcea <Endpoint_Read_Control_Stream_LE+0x9c>
     c7e:	85 30       	cpi	r24, 0x05	; 5
     c80:	11 f4       	brne	.+4      	; 0xc86 <Endpoint_Read_Control_Stream_LE+0x38>
     c82:	83 e0       	ldi	r24, 0x03	; 3
     c84:	32 c0       	rjmp	.+100    	; 0xcea <Endpoint_Read_Control_Stream_LE+0x9c>
     c86:	59 d1       	rcall	.+690    	; 0xf3a <Endpoint_IsSETUPReceived>
     c88:	81 11       	cpse	r24, r1
     c8a:	2e c0       	rjmp	.+92     	; 0xce8 <Endpoint_Read_Control_Stream_LE+0x9a>
     c8c:	3c d1       	rcall	.+632    	; 0xf06 <Endpoint_IsOUTReceived>
     c8e:	88 23       	and	r24, r24
     c90:	71 f3       	breq	.-36     	; 0xc6e <Endpoint_Read_Control_Stream_LE+0x20>
     c92:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     c96:	20 91 9c 22 	lds	r18, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     c9a:	30 91 9d 22 	lds	r19, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     c9e:	f9 01       	movw	r30, r18
     ca0:	87 ff       	sbrs	r24, 7
     ca2:	05 c0       	rjmp	.+10     	; 0xcae <Endpoint_Read_Control_Stream_LE+0x60>
     ca4:	ef 5b       	subi	r30, 0xBF	; 191
     ca6:	ff 4f       	sbci	r31, 0xFF	; 255
     ca8:	80 81       	ld	r24, Z
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	08 c0       	rjmp	.+16     	; 0xcbe <Endpoint_Read_Control_Stream_LE+0x70>
     cae:	e0 5c       	subi	r30, 0xC0	; 192
     cb0:	ff 4f       	sbci	r31, 0xFF	; 255
     cb2:	80 81       	ld	r24, Z
     cb4:	31 96       	adiw	r30, 0x01	; 1
     cb6:	20 81       	ld	r18, Z
     cb8:	90 e0       	ldi	r25, 0x00	; 0
     cba:	82 1b       	sub	r24, r18
     cbc:	91 09       	sbc	r25, r1
     cbe:	89 2b       	or	r24, r25
     cc0:	31 f0       	breq	.+12     	; 0xcce <Endpoint_Read_Control_Stream_LE+0x80>
     cc2:	c0 d0       	rcall	.+384    	; 0xe44 <Endpoint_Read_8>
     cc4:	f8 01       	movw	r30, r16
     cc6:	81 93       	st	Z+, r24
     cc8:	8f 01       	movw	r16, r30
     cca:	21 97       	sbiw	r28, 0x01	; 1
     ccc:	11 f7       	brne	.-60     	; 0xc92 <Endpoint_Read_Control_Stream_LE+0x44>
     cce:	ab d0       	rcall	.+342    	; 0xe26 <Endpoint_ClearOUT>
     cd0:	ce cf       	rjmp	.-100    	; 0xc6e <Endpoint_Read_Control_Stream_LE+0x20>
     cd2:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
     cd6:	88 23       	and	r24, r24
     cd8:	81 f2       	breq	.-96     	; 0xc7a <Endpoint_Read_Control_Stream_LE+0x2c>
     cda:	85 30       	cpi	r24, 0x05	; 5
     cdc:	91 f2       	breq	.-92     	; 0xc82 <Endpoint_Read_Control_Stream_LE+0x34>
     cde:	07 d1       	rcall	.+526    	; 0xeee <Endpoint_IsINReady>
     ce0:	88 23       	and	r24, r24
     ce2:	b9 f3       	breq	.-18     	; 0xcd2 <Endpoint_Read_Control_Stream_LE+0x84>
     ce4:	80 e0       	ldi	r24, 0x00	; 0
     ce6:	01 c0       	rjmp	.+2      	; 0xcea <Endpoint_Read_Control_Stream_LE+0x9c>
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	1f 91       	pop	r17
     cf0:	0f 91       	pop	r16
     cf2:	ff 90       	pop	r15
     cf4:	ef 90       	pop	r14
     cf6:	08 95       	ret

00000cf8 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
     cf8:	df 92       	push	r13
     cfa:	ef 92       	push	r14
     cfc:	ff 92       	push	r15
     cfe:	0f 93       	push	r16
     d00:	1f 93       	push	r17
     d02:	cf 93       	push	r28
     d04:	df 93       	push	r29
     d06:	d8 2f       	mov	r29, r24
     d08:	c9 2f       	mov	r28, r25
     d0a:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
     d0c:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     d10:	80 68       	ori	r24, 0x80	; 128
     d12:	b8 d0       	rcall	.+368    	; 0xe84 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
     d14:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <USB_ControlRequest+0x6>
     d18:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <USB_ControlRequest+0x7>
     d1c:	80 17       	cp	r24, r16
     d1e:	91 07       	cpc	r25, r17
     d20:	28 f0       	brcs	.+10     	; 0xd2c <Endpoint_Write_Control_PStream_LE+0x34>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
     d22:	01 15       	cp	r16, r1
     d24:	11 05       	cpc	r17, r1
	  Endpoint_ClearIN();
     d26:	19 f4       	brne	.+6      	; 0xd2e <Endpoint_Write_Control_PStream_LE+0x36>
     d28:	65 d0       	rcall	.+202    	; 0xdf4 <Endpoint_ClearIN>
     d2a:	01 c0       	rjmp	.+2      	; 0xd2e <Endpoint_Write_Control_PStream_LE+0x36>
     d2c:	8c 01       	movw	r16, r24
     d2e:	ed 2e       	mov	r14, r29
     d30:	fc 2e       	mov	r15, r28
     d32:	d1 2c       	mov	r13, r1

	while (Length || LastPacketFull)
     d34:	01 15       	cp	r16, r1
     d36:	11 05       	cpc	r17, r1
     d38:	09 f4       	brne	.+2      	; 0xd3c <Endpoint_Write_Control_PStream_LE+0x44>
     d3a:	42 c0       	rjmp	.+132    	; 0xdc0 <Endpoint_Write_Control_PStream_LE+0xc8>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     d3c:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     d40:	81 11       	cpse	r24, r1
     d42:	02 c0       	rjmp	.+4      	; 0xd48 <Endpoint_Write_Control_PStream_LE+0x50>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
     d44:	82 e0       	ldi	r24, 0x02	; 2
     d46:	4e c0       	rjmp	.+156    	; 0xde4 <Endpoint_Write_Control_PStream_LE+0xec>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     d48:	85 30       	cpi	r24, 0x05	; 5
     d4a:	11 f4       	brne	.+4      	; 0xd50 <Endpoint_Write_Control_PStream_LE+0x58>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
     d4c:	83 e0       	ldi	r24, 0x03	; 3
		else if (Endpoint_IsSETUPReceived())
     d4e:	4a c0       	rjmp	.+148    	; 0xde4 <Endpoint_Write_Control_PStream_LE+0xec>
     d50:	f4 d0       	rcall	.+488    	; 0xf3a <Endpoint_IsSETUPReceived>
     d52:	88 23       	and	r24, r24
		  return ENDPOINT_RWCSTREAM_HostAborted;
     d54:	11 f0       	breq	.+4      	; 0xd5a <Endpoint_Write_Control_PStream_LE+0x62>
     d56:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsOUTReceived())
     d58:	45 c0       	rjmp	.+138    	; 0xde4 <Endpoint_Write_Control_PStream_LE+0xec>
     d5a:	d5 d0       	rcall	.+426    	; 0xf06 <Endpoint_IsOUTReceived>
     d5c:	81 11       	cpse	r24, r1
		  break;

		if (Endpoint_IsINReady())
     d5e:	3e c0       	rjmp	.+124    	; 0xddc <Endpoint_Write_Control_PStream_LE+0xe4>
     d60:	c6 d0       	rcall	.+396    	; 0xeee <Endpoint_IsINReady>
     d62:	88 23       	and	r24, r24
     d64:	39 f3       	breq	.-50     	; 0xd34 <Endpoint_Write_Control_PStream_LE+0x3c>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
     d66:	20 91 a0 22 	lds	r18, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     d6a:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     d6e:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
				  return USB_Endpoint_SelectedFIFO->Position;
     d72:	fc 01       	movw	r30, r24
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
     d74:	27 ff       	sbrs	r18, 7
     d76:	05 c0       	rjmp	.+10     	; 0xd82 <Endpoint_Write_Control_PStream_LE+0x8a>
				  return USB_Endpoint_SelectedFIFO->Position;
     d78:	ef 5b       	subi	r30, 0xBF	; 191
     d7a:	ff 4f       	sbci	r31, 0xFF	; 255
     d7c:	c0 81       	ld	r28, Z
     d7e:	d0 e0       	ldi	r29, 0x00	; 0
     d80:	15 c0       	rjmp	.+42     	; 0xdac <Endpoint_Write_Control_PStream_LE+0xb4>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
     d82:	e0 5c       	subi	r30, 0xC0	; 192
     d84:	ff 4f       	sbci	r31, 0xFF	; 255
     d86:	c0 81       	ld	r28, Z
     d88:	31 96       	adiw	r30, 0x01	; 1
     d8a:	80 81       	ld	r24, Z
     d8c:	d0 e0       	ldi	r29, 0x00	; 0
     d8e:	c8 1b       	sub	r28, r24
     d90:	d1 09       	sbc	r29, r1
     d92:	0c c0       	rjmp	.+24     	; 0xdac <Endpoint_Write_Control_PStream_LE+0xb4>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
     d94:	c8 30       	cpi	r28, 0x08	; 8
     d96:	d1 05       	cpc	r29, r1
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
     d98:	60 f4       	brcc	.+24     	; 0xdb2 <Endpoint_Write_Control_PStream_LE+0xba>
     d9a:	f7 01       	movw	r30, r14
     d9c:	84 91       	lpm	r24, Z
     d9e:	62 d0       	rcall	.+196    	; 0xe64 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
     da0:	ff ef       	ldi	r31, 0xFF	; 255
     da2:	ef 1a       	sub	r14, r31
     da4:	ff 0a       	sbc	r15, r31
				Length--;
     da6:	01 50       	subi	r16, 0x01	; 1
     da8:	11 09       	sbc	r17, r1
				BytesInEndpoint++;
     daa:	21 96       	adiw	r28, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
     dac:	01 15       	cp	r16, r1
     dae:	11 05       	cpc	r17, r1
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
     db0:	89 f7       	brne	.-30     	; 0xd94 <Endpoint_Write_Control_PStream_LE+0x9c>
     db2:	dd 24       	eor	r13, r13
     db4:	d3 94       	inc	r13
     db6:	28 97       	sbiw	r28, 0x08	; 8
     db8:	09 f0       	breq	.+2      	; 0xdbc <Endpoint_Write_Control_PStream_LE+0xc4>
			Endpoint_ClearIN();
     dba:	d1 2c       	mov	r13, r1
     dbc:	1b d0       	rcall	.+54     	; 0xdf4 <Endpoint_ClearIN>
     dbe:	ba cf       	rjmp	.-140    	; 0xd34 <Endpoint_Write_Control_PStream_LE+0x3c>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
     dc0:	d1 10       	cpse	r13, r1
     dc2:	bc cf       	rjmp	.-136    	; 0xd3c <Endpoint_Write_Control_PStream_LE+0x44>
     dc4:	0b c0       	rjmp	.+22     	; 0xddc <Endpoint_Write_Control_PStream_LE+0xe4>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     dc6:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     dca:	88 23       	and	r24, r24
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <Endpoint_Write_Control_PStream_LE+0xd8>
     dce:	ba cf       	rjmp	.-140    	; 0xd44 <Endpoint_Write_Control_PStream_LE+0x4c>
     dd0:	85 30       	cpi	r24, 0x05	; 5
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
     dd2:	09 f4       	brne	.+2      	; 0xdd6 <Endpoint_Write_Control_PStream_LE+0xde>
     dd4:	bb cf       	rjmp	.-138    	; 0xd4c <Endpoint_Write_Control_PStream_LE+0x54>
     dd6:	b1 d0       	rcall	.+354    	; 0xf3a <Endpoint_IsSETUPReceived>
     dd8:	81 11       	cpse	r24, r1
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
     dda:	bd cf       	rjmp	.-134    	; 0xd56 <Endpoint_Write_Control_PStream_LE+0x5e>
     ddc:	94 d0       	rcall	.+296    	; 0xf06 <Endpoint_IsOUTReceived>
     dde:	88 23       	and	r24, r24
     de0:	91 f3       	breq	.-28     	; 0xdc6 <Endpoint_Write_Control_PStream_LE+0xce>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
     de2:	80 e0       	ldi	r24, 0x00	; 0
}
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	ff 90       	pop	r15
     dee:	ef 90       	pop	r14
     df0:	df 90       	pop	r13
     df2:	08 95       	ret

00000df4 <Endpoint_ClearIN>:
			return false;
		}
	}

	return true;
}
     df4:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     df8:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     dfc:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     e00:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     e04:	af 5b       	subi	r26, 0xBF	; 191
     e06:	bf 4f       	sbci	r27, 0xFF	; 255
     e08:	8c 91       	ld	r24, X
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	82 83       	std	Z+2, r24	; 0x02
     e0e:	93 83       	std	Z+3, r25	; 0x03
     e10:	80 81       	ld	r24, Z
     e12:	8d 79       	andi	r24, 0x9D	; 157
     e14:	80 83       	st	Z, r24
     e16:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     e1a:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     e1e:	ef 5b       	subi	r30, 0xBF	; 191
     e20:	ff 4f       	sbci	r31, 0xFF	; 255
     e22:	10 82       	st	Z, r1
     e24:	08 95       	ret

00000e26 <Endpoint_ClearOUT>:
     e26:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     e2a:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     e2e:	80 81       	ld	r24, Z
     e30:	8d 79       	andi	r24, 0x9D	; 157
     e32:	80 83       	st	Z, r24
     e34:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     e38:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     e3c:	ef 5b       	subi	r30, 0xBF	; 191
     e3e:	ff 4f       	sbci	r31, 0xFF	; 255
     e40:	10 82       	st	Z, r1
     e42:	08 95       	ret

00000e44 <Endpoint_Read_8>:
     e44:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     e48:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     e4c:	fc 01       	movw	r30, r24
     e4e:	ef 5b       	subi	r30, 0xBF	; 191
     e50:	ff 4f       	sbci	r31, 0xFF	; 255
     e52:	20 81       	ld	r18, Z
     e54:	31 e0       	ldi	r19, 0x01	; 1
     e56:	32 0f       	add	r19, r18
     e58:	30 83       	st	Z, r19
     e5a:	fc 01       	movw	r30, r24
     e5c:	e2 0f       	add	r30, r18
     e5e:	f1 1d       	adc	r31, r1
     e60:	80 81       	ld	r24, Z
     e62:	08 95       	ret

00000e64 <Endpoint_Write_8>:
     e64:	20 91 9c 22 	lds	r18, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     e68:	30 91 9d 22 	lds	r19, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     e6c:	f9 01       	movw	r30, r18
     e6e:	ef 5b       	subi	r30, 0xBF	; 191
     e70:	ff 4f       	sbci	r31, 0xFF	; 255
     e72:	90 81       	ld	r25, Z
     e74:	41 e0       	ldi	r20, 0x01	; 1
     e76:	49 0f       	add	r20, r25
     e78:	40 83       	st	Z, r20
     e7a:	f9 01       	movw	r30, r18
     e7c:	e9 0f       	add	r30, r25
     e7e:	f1 1d       	adc	r31, r1
     e80:	80 83       	st	Z, r24
     e82:	08 95       	ret

00000e84 <Endpoint_SelectEndpoint>:
     e84:	80 93 a0 22 	sts	0x22A0, r24	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     e88:	48 2f       	mov	r20, r24
     e8a:	4f 70       	andi	r20, 0x0F	; 15
     e8c:	50 e0       	ldi	r21, 0x00	; 0
     e8e:	60 91 c6 04 	lds	r22, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7de4c6>
     e92:	70 91 c7 04 	lds	r23, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7de4c7>
     e96:	9a 01       	movw	r18, r20
     e98:	94 e0       	ldi	r25, 0x04	; 4
     e9a:	22 0f       	add	r18, r18
     e9c:	33 1f       	adc	r19, r19
     e9e:	9a 95       	dec	r25
     ea0:	e1 f7       	brne	.-8      	; 0xe9a <Endpoint_SelectEndpoint+0x16>
     ea2:	e4 e8       	ldi	r30, 0x84	; 132
     ea4:	87 ff       	sbrs	r24, 7
     ea6:	11 c0       	rjmp	.+34     	; 0xeca <Endpoint_SelectEndpoint+0x46>
     ea8:	e4 9f       	mul	r30, r20
     eaa:	c0 01       	movw	r24, r0
     eac:	e5 9f       	mul	r30, r21
     eae:	90 0d       	add	r25, r0
     eb0:	11 24       	eor	r1, r1
     eb2:	8d 51       	subi	r24, 0x1D	; 29
     eb4:	9d 4d       	sbci	r25, 0xDD	; 221
     eb6:	80 93 9c 22 	sts	0x229C, r24	; 0x80229c <USB_Endpoint_SelectedFIFO>
     eba:	90 93 9d 22 	sts	0x229D, r25	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     ebe:	c9 01       	movw	r24, r18
     ec0:	08 96       	adiw	r24, 0x08	; 8
     ec2:	9b 01       	movw	r18, r22
     ec4:	28 0f       	add	r18, r24
     ec6:	39 1f       	adc	r19, r25
     ec8:	0d c0       	rjmp	.+26     	; 0xee4 <Endpoint_SelectEndpoint+0x60>
     eca:	e4 9f       	mul	r30, r20
     ecc:	c0 01       	movw	r24, r0
     ece:	e5 9f       	mul	r30, r21
     ed0:	90 0d       	add	r25, r0
     ed2:	11 24       	eor	r1, r1
     ed4:	8f 55       	subi	r24, 0x5F	; 95
     ed6:	9d 4d       	sbci	r25, 0xDD	; 221
     ed8:	80 93 9c 22 	sts	0x229C, r24	; 0x80229c <USB_Endpoint_SelectedFIFO>
     edc:	90 93 9d 22 	sts	0x229D, r25	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     ee0:	26 0f       	add	r18, r22
     ee2:	37 1f       	adc	r19, r23
     ee4:	20 93 9e 22 	sts	0x229E, r18	; 0x80229e <USB_Endpoint_SelectedHandle>
     ee8:	30 93 9f 22 	sts	0x229F, r19	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     eec:	08 95       	ret

00000eee <Endpoint_IsINReady>:
     eee:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     ef2:	80 68       	ori	r24, 0x80	; 128
     ef4:	c7 df       	rcall	.-114    	; 0xe84 <Endpoint_SelectEndpoint>
     ef6:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     efa:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     efe:	80 81       	ld	r24, Z
     f00:	86 95       	lsr	r24
     f02:	81 70       	andi	r24, 0x01	; 1
     f04:	08 95       	ret

00000f06 <Endpoint_IsOUTReceived>:
     f06:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     f0a:	8f 77       	andi	r24, 0x7F	; 127
     f0c:	bb df       	rcall	.-138    	; 0xe84 <Endpoint_SelectEndpoint>
     f0e:	a0 91 9e 22 	lds	r26, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     f12:	b0 91 9f 22 	lds	r27, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     f16:	8c 91       	ld	r24, X
     f18:	85 ff       	sbrs	r24, 5
     f1a:	0d c0       	rjmp	.+26     	; 0xf36 <Endpoint_IsOUTReceived+0x30>
     f1c:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     f20:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     f24:	12 96       	adiw	r26, 0x02	; 2
     f26:	8d 91       	ld	r24, X+
     f28:	9c 91       	ld	r25, X
     f2a:	13 97       	sbiw	r26, 0x03	; 3
     f2c:	e0 5c       	subi	r30, 0xC0	; 192
     f2e:	ff 4f       	sbci	r31, 0xFF	; 255
     f30:	80 83       	st	Z, r24
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	08 95       	ret
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	08 95       	ret

00000f3a <Endpoint_IsSETUPReceived>:
     f3a:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     f3e:	8f 77       	andi	r24, 0x7F	; 127
     f40:	a1 df       	rcall	.-190    	; 0xe84 <Endpoint_SelectEndpoint>
     f42:	a0 91 9e 22 	lds	r26, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     f46:	b0 91 9f 22 	lds	r27, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     f4a:	8c 91       	ld	r24, X
     f4c:	84 ff       	sbrs	r24, 4
     f4e:	0d c0       	rjmp	.+26     	; 0xf6a <Endpoint_IsSETUPReceived+0x30>
     f50:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     f54:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     f58:	12 96       	adiw	r26, 0x02	; 2
     f5a:	8d 91       	ld	r24, X+
     f5c:	9c 91       	ld	r25, X
     f5e:	13 97       	sbiw	r26, 0x03	; 3
     f60:	e0 5c       	subi	r30, 0xC0	; 192
     f62:	ff 4f       	sbci	r31, 0xFF	; 255
     f64:	80 83       	st	Z, r24
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	08 95       	ret
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	08 95       	ret

00000f6e <Endpoint_ClearSETUP>:
     f6e:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     f72:	8f 77       	andi	r24, 0x7F	; 127
     f74:	87 df       	rcall	.-242    	; 0xe84 <Endpoint_SelectEndpoint>
     f76:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     f7a:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     f7e:	80 81       	ld	r24, Z
     f80:	8d 78       	andi	r24, 0x8D	; 141
     f82:	80 83       	st	Z, r24
     f84:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     f88:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     f8c:	80 81       	ld	r24, Z
     f8e:	81 60       	ori	r24, 0x01	; 1
     f90:	80 83       	st	Z, r24
     f92:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     f96:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     f9a:	ef 5b       	subi	r30, 0xBF	; 191
     f9c:	ff 4f       	sbci	r31, 0xFF	; 255
     f9e:	10 82       	st	Z, r1
     fa0:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     fa4:	80 68       	ori	r24, 0x80	; 128
     fa6:	6e df       	rcall	.-292    	; 0xe84 <Endpoint_SelectEndpoint>
     fa8:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     fac:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     fb0:	80 81       	ld	r24, Z
     fb2:	81 60       	ori	r24, 0x01	; 1
     fb4:	80 83       	st	Z, r24
     fb6:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
     fba:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
     fbe:	ef 5b       	subi	r30, 0xBF	; 191
     fc0:	ff 4f       	sbci	r31, 0xFF	; 255
     fc2:	10 82       	st	Z, r1
     fc4:	08 95       	ret

00000fc6 <Endpoint_StallTransaction>:
     fc6:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     fca:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     fce:	81 81       	ldd	r24, Z+1	; 0x01
     fd0:	84 60       	ori	r24, 0x04	; 4
     fd2:	81 83       	std	Z+1, r24	; 0x01
     fd4:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     fd8:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     fdc:	81 81       	ldd	r24, Z+1	; 0x01
     fde:	80 7c       	andi	r24, 0xC0	; 192
     fe0:	80 34       	cpi	r24, 0x40	; 64
     fe2:	59 f4       	brne	.+22     	; 0xffa <Endpoint_StallTransaction+0x34>
     fe4:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>
     fe8:	80 58       	subi	r24, 0x80	; 128
     fea:	4c df       	rcall	.-360    	; 0xe84 <Endpoint_SelectEndpoint>
     fec:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
     ff0:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
     ff4:	81 81       	ldd	r24, Z+1	; 0x01
     ff6:	84 60       	ori	r24, 0x04	; 4
     ff8:	81 83       	std	Z+1, r24	; 0x01
     ffa:	08 95       	ret

00000ffc <Endpoint_ConfigureEndpoint_PRV>:
     ffc:	1f 93       	push	r17
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	c8 2f       	mov	r28, r24
    1004:	16 2f       	mov	r17, r22
    1006:	d4 2f       	mov	r29, r20
    1008:	3d df       	rcall	.-390    	; 0xe84 <Endpoint_SelectEndpoint>
    100a:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
    100e:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
    1012:	11 82       	std	Z+1, r1	; 0x01
    1014:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
    1018:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
    101c:	8c 2f       	mov	r24, r28
    101e:	88 1f       	adc	r24, r24
    1020:	88 27       	eor	r24, r24
    1022:	88 1f       	adc	r24, r24
    1024:	88 0f       	add	r24, r24
    1026:	80 83       	st	Z, r24
    1028:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
    102c:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
    1030:	11 83       	std	Z+1, r17	; 0x01
    1032:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
    1036:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
    103a:	12 82       	std	Z+2, r1	; 0x02
    103c:	13 82       	std	Z+3, r1	; 0x03
    103e:	20 91 9c 22 	lds	r18, 0x229C	; 0x80229c <USB_Endpoint_SelectedFIFO>
    1042:	30 91 9d 22 	lds	r19, 0x229D	; 0x80229d <USB_Endpoint_SelectedFIFO+0x1>
    1046:	24 83       	std	Z+4, r18	; 0x04
    1048:	35 83       	std	Z+5, r19	; 0x05
    104a:	cc 0f       	add	r28, r28
    104c:	cc 0b       	sbc	r28, r28
    104e:	cd 23       	and	r28, r29
    1050:	f9 01       	movw	r30, r18
    1052:	e0 5c       	subi	r30, 0xC0	; 192
    1054:	ff 4f       	sbci	r31, 0xFF	; 255
    1056:	c0 83       	st	Z, r28
    1058:	31 96       	adiw	r30, 0x01	; 1
    105a:	10 82       	st	Z, r1
    105c:	81 e0       	ldi	r24, 0x01	; 1
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	1f 91       	pop	r17
    1064:	08 95       	ret

00001066 <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	90 e0       	ldi	r25, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    106a:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7de4c6>
    106e:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7de4c7>
    1072:	9c 01       	movw	r18, r24
    1074:	44 e0       	ldi	r20, 0x04	; 4
    1076:	22 0f       	add	r18, r18
    1078:	33 1f       	adc	r19, r19
    107a:	4a 95       	dec	r20
    107c:	e1 f7       	brne	.-8      	; 0x1076 <Endpoint_ClearEndpoints+0x10>
    107e:	e2 0f       	add	r30, r18
    1080:	f3 1f       	adc	r31, r19
    1082:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    1084:	40 91 c6 04 	lds	r20, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7de4c6>
    1088:	50 91 c7 04 	lds	r21, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7de4c7>
    108c:	fa 01       	movw	r30, r20
    108e:	e2 0f       	add	r30, r18
    1090:	f3 1f       	adc	r31, r19
    1092:	11 82       	std	Z+1, r1	; 0x01
    1094:	01 96       	adiw	r24, 0x01	; 1
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1096:	85 30       	cpi	r24, 0x05	; 5
    1098:	91 05       	cpc	r25, r1
    109a:	39 f7       	brne	.-50     	; 0x106a <Endpoint_ClearEndpoints+0x4>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    109c:	08 95       	ret

0000109e <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    109e:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <USB_ControlRequest>
    10a2:	87 ff       	sbrs	r24, 7
    10a4:	0d c0       	rjmp	.+26     	; 0x10c0 <Endpoint_ClearStatusStage+0x22>
	{
		while (!(Endpoint_IsOUTReceived()))
    10a6:	2f df       	rcall	.-418    	; 0xf06 <Endpoint_IsOUTReceived>
    10a8:	81 11       	cpse	r24, r1
    10aa:	05 c0       	rjmp	.+10     	; 0x10b6 <Endpoint_ClearStatusStage+0x18>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    10ac:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
    10b0:	81 11       	cpse	r24, r1
    10b2:	f9 cf       	rjmp	.-14     	; 0x10a6 <Endpoint_ClearStatusStage+0x8>
			  return;
		}

		Endpoint_ClearOUT();
    10b4:	09 c0       	rjmp	.+18     	; 0x10c8 <Endpoint_ClearStatusStage+0x2a>
    10b6:	b7 ce       	rjmp	.-658    	; 0xe26 <Endpoint_ClearOUT>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    10b8:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>
    10bc:	88 23       	and	r24, r24

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    10be:	21 f0       	breq	.+8      	; 0x10c8 <Endpoint_ClearStatusStage+0x2a>
    10c0:	16 df       	rcall	.-468    	; 0xeee <Endpoint_IsINReady>
    10c2:	88 23       	and	r24, r24
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    10c4:	c9 f3       	breq	.-14     	; 0x10b8 <Endpoint_ClearStatusStage+0x1a>
    10c6:	96 ce       	rjmp	.-724    	; 0xdf4 <Endpoint_ClearIN>
    10c8:	08 95       	ret

000010ca <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    10ca:	0f 93       	push	r16
    10cc:	1f 93       	push	r17
    10ce:	cf 93       	push	r28
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    10d0:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7de4c6>
    10d4:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7de4c7>
    10d8:	e0 5b       	subi	r30, 0xB0	; 176
    10da:	ff 4f       	sbci	r31, 0xFF	; 255
    10dc:	00 81       	ld	r16, Z
    10de:	11 81       	ldd	r17, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    10e0:	c4 e6       	ldi	r28, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    10e2:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <USB_Endpoint_SelectedEndpoint>

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    10e6:	87 ff       	sbrs	r24, 7
    10e8:	0a c0       	rjmp	.+20     	; 0x10fe <Endpoint_WaitUntilReady+0x34>
		{
			if (Endpoint_IsINReady())
    10ea:	01 df       	rcall	.-510    	; 0xeee <Endpoint_IsINReady>
    10ec:	81 11       	cpse	r24, r1
    10ee:	05 c0       	rjmp	.+10     	; 0x10fa <Endpoint_WaitUntilReady+0x30>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    10f0:	80 91 93 22 	lds	r24, 0x2293	; 0x802293 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    10f4:	81 11       	cpse	r24, r1
    10f6:	05 c0       	rjmp	.+10     	; 0x1102 <Endpoint_WaitUntilReady+0x38>
    10f8:	22 c0       	rjmp	.+68     	; 0x113e <Endpoint_WaitUntilReady+0x74>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    10fa:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    10fc:	25 c0       	rjmp	.+74     	; 0x1148 <Endpoint_WaitUntilReady+0x7e>
    10fe:	03 df       	rcall	.-506    	; 0xf06 <Endpoint_IsOUTReceived>
    1100:	f5 cf       	rjmp	.-22     	; 0x10ec <Endpoint_WaitUntilReady+0x22>

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1102:	85 30       	cpi	r24, 0x05	; 5
    1104:	f1 f0       	breq	.+60     	; 0x1142 <Endpoint_WaitUntilReady+0x78>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    1106:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <USB_Endpoint_SelectedHandle>
    110a:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <USB_Endpoint_SelectedHandle+0x1>
    110e:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1110:	82 fd       	sbrc	r24, 2
    1112:	19 c0       	rjmp	.+50     	; 0x1146 <Endpoint_WaitUntilReady+0x7c>
    1114:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <__TEXT_REGION_LENGTH__+0x7de4c6>
    1118:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <__TEXT_REGION_LENGTH__+0x7de4c7>
    111c:	e0 5b       	subi	r30, 0xB0	; 176
    111e:	ff 4f       	sbci	r31, 0xFF	; 255
    1120:	80 81       	ld	r24, Z
    1122:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1124:	08 17       	cp	r16, r24
    1126:	19 07       	cpc	r17, r25
    1128:	11 f4       	brne	.+4      	; 0x112e <Endpoint_WaitUntilReady+0x64>
    112a:	8c 01       	movw	r16, r24
    112c:	da cf       	rjmp	.-76     	; 0x10e2 <Endpoint_WaitUntilReady+0x18>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    112e:	2f ef       	ldi	r18, 0xFF	; 255
    1130:	2c 0f       	add	r18, r28
    1132:	cc 23       	and	r28, r28
    1134:	11 f0       	breq	.+4      	; 0x113a <Endpoint_WaitUntilReady+0x70>
    1136:	c2 2f       	mov	r28, r18
    1138:	f8 cf       	rjmp	.-16     	; 0x112a <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_Timeout;
    113a:	84 e0       	ldi	r24, 0x04	; 4
    113c:	05 c0       	rjmp	.+10     	; 0x1148 <Endpoint_WaitUntilReady+0x7e>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    113e:	82 e0       	ldi	r24, 0x02	; 2
    1140:	03 c0       	rjmp	.+6      	; 0x1148 <Endpoint_WaitUntilReady+0x7e>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1142:	83 e0       	ldi	r24, 0x03	; 3
    1144:	01 c0       	rjmp	.+2      	; 0x1148 <Endpoint_WaitUntilReady+0x7e>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1146:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1148:	cf 91       	pop	r28
    114a:	1f 91       	pop	r17
    114c:	0f 91       	pop	r16
    114e:	08 95       	ret

00001150 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    1154:	e0 e4       	ldi	r30, 0x40	; 64
    1156:	f0 e0       	ldi	r31, 0x00	; 0
    1158:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    115a:	84 81       	ldd	r24, Z+4	; 0x04
    115c:	83 60       	ori	r24, 0x03	; 3
    115e:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    1160:	4f d0       	rcall	.+158    	; 0x1200 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1162:	55 d0       	rcall	.+170    	; 0x120e <USB_INT_ClearAllInterrupts>
    1164:	c0 ec       	ldi	r28, 0xC0	; 192
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    1166:	d4 e0       	ldi	r29, 0x04	; 4
    1168:	88 81       	ld	r24, Y
    116a:	8f 77       	andi	r24, 0x7F	; 127
    116c:	88 83       	st	Y, r24
    116e:	88 81       	ld	r24, Y
				USB.CTRLA |=  USB_ENABLE_bm;
    1170:	80 68       	ori	r24, 0x80	; 128
    1172:	88 83       	st	Y, r24
    1174:	10 92 93 22 	sts	0x2293, r1	; 0x802293 <USB_DeviceState>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1178:	10 92 8f 22 	sts	0x228F, r1	; 0x80228f <USB_Device_ConfigurationNumber>
	USB_Device_ConfigurationNumber  = 0;
    117c:	10 92 91 22 	sts	0x2291, r1	; 0x802291 <USB_Device_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1180:	10 92 90 22 	sts	0x2290, r1	; 0x802290 <USB_Device_CurrentlySelfPowered>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1184:	88 81       	ld	r24, Y
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    1186:	80 64       	ori	r24, 0x40	; 64
    1188:	88 83       	st	Y, r24
    118a:	48 e0       	ldi	r20, 0x08	; 8
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    118c:	68 e4       	ldi	r22, 0x48	; 72
    118e:	80 e8       	ldi	r24, 0x80	; 128
    1190:	35 df       	rcall	.-406    	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
    1192:	48 e0       	ldi	r20, 0x08	; 8

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    1194:	68 e4       	ldi	r22, 0x48	; 72
    1196:	80 e0       	ldi	r24, 0x00	; 0
    1198:	31 df       	rcall	.-414    	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
    119a:	88 85       	ldd	r24, Y+8	; 0x08
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    119c:	80 64       	ori	r24, 0x40	; 64
    119e:	88 87       	std	Y+8, r24	; 0x08
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    11a2:	81 60       	ori	r24, 0x01	; 1
    11a4:	89 83       	std	Y+1, r24	; 0x01
    11a6:	df 91       	pop	r29
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    11a8:	cf 91       	pop	r28
    11aa:	08 95       	ret

000011ac <USB_Init>:
    11ac:	cf 93       	push	r28

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    11ae:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    11b0:	2f b7       	in	r18, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    11b2:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    11b4:	c0 ec       	ldi	r28, 0xC0	; 192
    11b6:	d1 e0       	ldi	r29, 0x01	; 1
    11b8:	82 e0       	ldi	r24, 0x02	; 2
    11ba:	8a 87       	std	Y+10, r24	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    11bc:	ea e1       	ldi	r30, 0x1A	; 26
    11be:	f0 e0       	ldi	r31, 0x00	; 0
    11c0:	e4 91       	lpm	r30, Z
    11c2:	a0 ec       	ldi	r26, 0xC0	; 192
    11c4:	b4 e0       	ldi	r27, 0x04	; 4
    11c6:	da 96       	adiw	r26, 0x3a	; 58
    11c8:	ec 93       	st	X, r30
    11ca:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    11cc:	eb e1       	ldi	r30, 0x1B	; 27
    11ce:	f0 e0       	ldi	r31, 0x00	; 0
    11d0:	e4 91       	lpm	r30, Z
    11d2:	db 96       	adiw	r26, 0x3b	; 59
    11d4:	ec 93       	st	X, r30
    11d6:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    11d8:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    11da:	86 e3       	ldi	r24, 0x36	; 54
    11dc:	95 e2       	ldi	r25, 0x25	; 37
    11de:	8e 7f       	andi	r24, 0xFE	; 254
    11e0:	16 96       	adiw	r26, 0x06	; 6
    11e2:	8d 93       	st	X+, r24
    11e4:	9c 93       	st	X, r25
    11e6:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    11e8:	84 e1       	ldi	r24, 0x14	; 20
    11ea:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
    11ec:	83 e0       	ldi	r24, 0x03	; 3
    11ee:	18 96       	adiw	r26, 0x08	; 8
    11f0:	8c 93       	st	X, r24
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    11f2:	2f bf       	out	0x3f, r18	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	80 93 92 22 	sts	0x2292, r24	; 0x802292 <USB_IsInitialized>

	USB_ResetInterface();
}
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;

	USB_ResetInterface();
    11fe:	a8 cf       	rjmp	.-176    	; 0x1150 <USB_ResetInterface>

00001200 <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    1200:	e0 ec       	ldi	r30, 0xC0	; 192
    1202:	f4 e0       	ldi	r31, 0x04	; 4
    1204:	80 85       	ldd	r24, Z+8	; 0x08
    1206:	83 70       	andi	r24, 0x03	; 3
    1208:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    120a:	11 86       	std	Z+9, r1	; 0x09
    120c:	08 95       	ret

0000120e <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    120e:	e0 ec       	ldi	r30, 0xC0	; 192
    1210:	f4 e0       	ldi	r31, 0x04	; 4
    1212:	8f ef       	ldi	r24, 0xFF	; 255
    1214:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    1216:	84 87       	std	Z+12, r24	; 0x0c
    1218:	08 95       	ret

0000121a <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    121a:	1f 92       	push	r1
    121c:	0f 92       	push	r0
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	0f 92       	push	r0
    1222:	11 24       	eor	r1, r1
    1224:	08 b6       	in	r0, 0x38	; 56
    1226:	0f 92       	push	r0
    1228:	18 be       	out	0x38, r1	; 56
    122a:	09 b6       	in	r0, 0x39	; 57
    122c:	0f 92       	push	r0
    122e:	19 be       	out	0x39, r1	; 57
    1230:	0b b6       	in	r0, 0x3b	; 59
    1232:	0f 92       	push	r0
    1234:	1b be       	out	0x3b, r1	; 59
    1236:	2f 93       	push	r18
    1238:	3f 93       	push	r19
    123a:	4f 93       	push	r20
    123c:	5f 93       	push	r21
    123e:	6f 93       	push	r22
    1240:	7f 93       	push	r23
    1242:	8f 93       	push	r24
    1244:	9f 93       	push	r25
    1246:	af 93       	push	r26
    1248:	bf 93       	push	r27
    124a:	ef 93       	push	r30
    124c:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    124e:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1252:	87 ff       	sbrs	r24, 7
    1254:	08 c0       	rjmp	.+16     	; 0x1266 <__vector_125+0x4c>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    1256:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <__TEXT_REGION_LENGTH__+0x7de4c8>
    125a:	87 ff       	sbrs	r24, 7
    125c:	04 c0       	rjmp	.+8      	; 0x1266 <__vector_125+0x4c>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    125e:	80 e8       	ldi	r24, 0x80	; 128
    1260:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1264:	cc db       	rcall	.-2152   	; 0x9fe <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    1266:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    126a:	86 ff       	sbrs	r24, 6
    126c:	06 c0       	rjmp	.+12     	; 0x127a <__vector_125+0x60>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    126e:	80 e4       	ldi	r24, 0x40	; 64
    1270:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    1274:	10 92 93 22 	sts	0x2293, r1	; 0x802293 <USB_DeviceState>
		EVENT_USB_Device_Disconnect();
    1278:	05 d9       	rcall	.-3574   	; 0x484 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    127a:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    127e:	85 ff       	sbrs	r24, 5
    1280:	13 c0       	rjmp	.+38     	; 0x12a8 <__vector_125+0x8e>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    1282:	80 e2       	ldi	r24, 0x20	; 32
    1284:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    1288:	80 91 8f 22 	lds	r24, 0x228F	; 0x80228f <USB_Device_ConfigurationNumber>
    128c:	88 23       	and	r24, r24
    128e:	11 f0       	breq	.+4      	; 0x1294 <__vector_125+0x7a>
		  USB_DeviceState = DEVICE_STATE_Configured;
    1290:	84 e0       	ldi	r24, 0x04	; 4
    1292:	07 c0       	rjmp	.+14     	; 0x12a2 <__vector_125+0x88>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    1294:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7de4c3>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1298:	81 11       	cpse	r24, r1
    129a:	02 c0       	rjmp	.+4      	; 0x12a0 <__vector_125+0x86>
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	01 c0       	rjmp	.+2      	; 0x12a2 <__vector_125+0x88>
    12a0:	83 e0       	ldi	r24, 0x03	; 3
    12a2:	80 93 93 22 	sts	0x2293, r24	; 0x802293 <USB_DeviceState>

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    12a6:	ed d8       	rcall	.-3622   	; 0x482 <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    12a8:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    12ac:	84 ff       	sbrs	r24, 4
    12ae:	14 c0       	rjmp	.+40     	; 0x12d8 <__vector_125+0xbe>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    12b0:	80 e1       	ldi	r24, 0x10	; 16
    12b2:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__TEXT_REGION_LENGTH__+0x7de4ca>
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    12b6:	82 e0       	ldi	r24, 0x02	; 2
    12b8:	80 93 93 22 	sts	0x2293, r24	; 0x802293 <USB_DeviceState>
		USB_Device_ConfigurationNumber = 0;
    12bc:	10 92 8f 22 	sts	0x228F, r1	; 0x80228f <USB_Device_ConfigurationNumber>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    12c0:	10 92 c3 04 	sts	0x04C3, r1	; 0x8004c3 <__TEXT_REGION_LENGTH__+0x7de4c3>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    12c4:	d0 de       	rcall	.-608    	; 0x1066 <Endpoint_ClearEndpoints>
    12c6:	48 e0       	ldi	r20, 0x08	; 8
    12c8:	68 e4       	ldi	r22, 0x48	; 72
    12ca:	80 e8       	ldi	r24, 0x80	; 128

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    12cc:	97 de       	rcall	.-722    	; 0xffc <Endpoint_ConfigureEndpoint_PRV>
    12ce:	48 e0       	ldi	r20, 0x08	; 8
    12d0:	68 e4       	ldi	r22, 0x48	; 72
    12d2:	80 e0       	ldi	r24, 0x00	; 0
    12d4:	93 de       	rcall	.-730    	; 0xffc <Endpoint_ConfigureEndpoint_PRV>

		Endpoint_ClearEndpoints();
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    12d6:	93 db       	rcall	.-2266   	; 0x9fe <USB_Event_Stub>
    12d8:	ff 91       	pop	r31
	}
}
    12da:	ef 91       	pop	r30
    12dc:	bf 91       	pop	r27
    12de:	af 91       	pop	r26
    12e0:	9f 91       	pop	r25
    12e2:	8f 91       	pop	r24
    12e4:	7f 91       	pop	r23
    12e6:	6f 91       	pop	r22
    12e8:	5f 91       	pop	r21
    12ea:	4f 91       	pop	r20
    12ec:	3f 91       	pop	r19
    12ee:	2f 91       	pop	r18
    12f0:	0f 90       	pop	r0
    12f2:	0b be       	out	0x3b, r0	; 59
    12f4:	0f 90       	pop	r0
    12f6:	09 be       	out	0x39, r0	; 57
    12f8:	0f 90       	pop	r0
    12fa:	08 be       	out	0x38, r0	; 56
    12fc:	0f 90       	pop	r0
    12fe:	0f be       	out	0x3f, r0	; 63
    1300:	0f 90       	pop	r0
    1302:	1f 90       	pop	r1
    1304:	18 95       	reti

00001306 <__udivmodsi4>:
    1306:	a1 e2       	ldi	r26, 0x21	; 33
    1308:	1a 2e       	mov	r1, r26
    130a:	aa 1b       	sub	r26, r26
    130c:	bb 1b       	sub	r27, r27
    130e:	fd 01       	movw	r30, r26
    1310:	0d c0       	rjmp	.+26     	; 0x132c <__udivmodsi4_ep>

00001312 <__udivmodsi4_loop>:
    1312:	aa 1f       	adc	r26, r26
    1314:	bb 1f       	adc	r27, r27
    1316:	ee 1f       	adc	r30, r30
    1318:	ff 1f       	adc	r31, r31
    131a:	a2 17       	cp	r26, r18
    131c:	b3 07       	cpc	r27, r19
    131e:	e4 07       	cpc	r30, r20
    1320:	f5 07       	cpc	r31, r21
    1322:	20 f0       	brcs	.+8      	; 0x132c <__udivmodsi4_ep>
    1324:	a2 1b       	sub	r26, r18
    1326:	b3 0b       	sbc	r27, r19
    1328:	e4 0b       	sbc	r30, r20
    132a:	f5 0b       	sbc	r31, r21

0000132c <__udivmodsi4_ep>:
    132c:	66 1f       	adc	r22, r22
    132e:	77 1f       	adc	r23, r23
    1330:	88 1f       	adc	r24, r24
    1332:	99 1f       	adc	r25, r25
    1334:	1a 94       	dec	r1
    1336:	69 f7       	brne	.-38     	; 0x1312 <__udivmodsi4_loop>
    1338:	60 95       	com	r22
    133a:	70 95       	com	r23
    133c:	80 95       	com	r24
    133e:	90 95       	com	r25
    1340:	9b 01       	movw	r18, r22
    1342:	ac 01       	movw	r20, r24
    1344:	bd 01       	movw	r22, r26
    1346:	cf 01       	movw	r24, r30
    1348:	08 95       	ret

0000134a <_exit>:
    134a:	f8 94       	cli

0000134c <__stop_program>:
    134c:	ff cf       	rjmp	.-2      	; 0x134c <__stop_program>
